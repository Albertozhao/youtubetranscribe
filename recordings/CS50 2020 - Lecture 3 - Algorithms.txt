 Nothing. Alright, this is CS50 and this is week 3. And you recall that last week we equipped you with all the more tools by which to solve problems, not only problems that we had proposed, but problems in your own code, that is to say bugs. And recall that those tools involve command line tools like help50 for help with cryptic error messages that the compiler might spit out, style50 which gives you a bit of feedback on the stylization of your code, the aesthetics thereof, check50 which checks the correctness of your code against the specifications in a given problem set or lab, printf which is a function that exists in some form in almost any programming language that you might ultimately learn. And this is simply a way of printing out anything you might want from the computer's memory onto the screen. Then perhaps the most powerful of these tools was debug50 which was this interactive debugger and even though this command debug50 is a little specific to CS50, what it triggers to happen, that little side window where you can see the stack of functions that you might have called during some breakpoint and you can see the local variables that you might have defined at some point during the execution of your code, that's a very common conventional feature of any debugger with most any language. And then lastly recall there was this DDB duck debugger which of course takes this physical form if you happen to have a rubber duck lying around with whom you can talk. But I'm so pleased to say that if you lack that currently while at home, CS50's own Kareem and Brenda and Sophie have wonderfully added, if you haven't noticed already, that same virtual duck to CS50 IDE. So if you click in the top corner, you can actually begin to have a chat of sorts with the rubber duck. And while this is certainly more playful incarnation of that same idea, we really can't emphasize enough the value of talking through problems when you're experiencing them in code with someone else or with something else. This particular duck, not all that large of a vocabulary, but it's not so much what the other person says, but what you say and what you hear yourself saying that is undoubtedly the most valuable part of the process. So our thanks to Kareem and Brenda and Sophie on that. Recall last week too that we took a look underneath the hood literally in some sense at the computer's memory in your laptop or desktop or phone. And then we decided to think about this more artistically as just a grid of bytes. So within that chip, there's a whole bunch of bits. And if you look at eight of them at a time, there's a whole bunch of bytes. And it stands to reason that we could think of this as like the first byte, the second byte, the third byte, and so forth and sort of chop this up pictorially into just a whole sequence of bytes in the computer's memory. And recall that if we zoom in on that and focus on just one contiguous block of memory, otherwise known as an array, we can do things within this array like storing a bunch of different values. So recall last week, we started by defining a little goofily multiple variables that were almost identically named like scores one, scores two, scores three. And then we began to clean up the design of our code by introducing an array so we can have just one variable called scores that is of size three and has room for multiple values. So today we'll continue to leverage this feature of many programming languages, being able to store things continuously back to back to back to back in a computer's memory because this very simple layout, this very simple feature of the language is going to open up all sorts of powerful features. And in fact, we can even revisit some of the problems we tried to solve way back in week zero. But there is a catch with arrays. And we didn't really emphasize as much last week. And that's because even though you and I can glance at this picture on the screen and see immediately that though there's seven boxes on the screen, there's seven locations in which you can store values, you and I can sort of have this bird's eye view of everything and just see what's inside that entire array all at once. So a computer's recall are much more methodical, more algorithmic, if you will. And so a computer as powerful as they are can technically only look at one location and an array at a time. So whereas you and I can glance at this and sort of take it all in at once, a computer just can't glance at its memory and take in all at once all of the values therein. It has to do so more methodically, for instance, from left to right, maybe right to left, maybe middle onward, but it has to be an algorithm. So today we'll formalize that notion and really kind of hide the fact that this array cannot be seen all at once. You can only look at one location and an array at a given time. And this is going to have very real implications. For instance, if we consider that very first problem in the very first week where we tried to find my phone number in a phone book, the very naive approach was to start at the beginning and search from left to right. And we tried a couple of variants thereafter. But the problem, quite simply, is that of searching. And this is a term of art and computer science, super common, certainly for you and I as users on Google and the like to search for things all day long. And so certainly searching well, designing a search algorithm well is certainly a compelling feature of so many of today's tools that you and I use. So if we think of this really as a problem to solve, we've got some input, which for instance might be an array of numbers, or maybe an array of web pages, in the case of Google. And the goal is to get some output. So if the input to the problem is an array of values, the output hopefully is going to be something as simple, really, as a bull. Yes or no is the value you're looking for a discoverable. Can you search for and find that value? Yes or no, true or false. Now within this black box recall is going to be some algorithm. And that's where today we'll spend most of our time. Indeed, we won't really introduce that many more features of C. We won't introduce that much more code. We'll focus again on ideas just taking for granted now that you have some more tools in your toolkit, beyond loops and conditions and Boolean expressions. We now have this other tool known as arrays. But let's first introduce some other terms of art, some jargon, if you will, related to what we'll call running time. So we've alluded to this a few times when we're thinking about just how good or bad an algorithm is, we describe how long it takes to run. That is, it's running time. The running time of an algorithm is how long it takes, how many steps it takes, how many seconds it takes, how many iterations it takes. It doesn't really matter what your unit of measure is. Maybe it's time, maybe it's iterations or something else. But running time just refers to how long does an algorithm take. And there are ways that we can think about this a little more formally. And we kind of did this already in the first week, but we didn't give it this name. This italicized O, this capital O on the screen, is otherwise known as big O notation. And computer scientists and some mathematicians will very frequently use, literally, this symbol to describe the running times of algorithms, or mathematically like a function. So recall this picture, in fact. When we were searching that phone book, we did it sort of good, better, best. We did it linearly. That is, searching one page at a time. We did it twice as fast by doing two pages at a time. And then we did it logarithmically by dividing and conquering, and half and half and half. And at the time, I proposed that if we think of a phone book as having n pages, where n is just a number in computer science vernacular, we might describe the running time, or the number of steps involved for that first algorithm, as being maybe in the worst case n steps. If the person you're looking for in a phone book maybe alphabetically has a last name starting with z in English, well, the z might be all the way at the end of the phone book. So at the worst case, you might be taking n steps to find someone like myself in that phone book. The second algorithm, though, was twice as fast because we went two pages at a time. So we might describe it's running time as n divided by two. And then the third algorithm, where we divided the problem in half and half and half, literally throwing half of the problem away again and again, was logarithmic, technically log base two of n, which again is just a mathematical formula that refers to having something again and again and again. And you start with, of course, n pages in that scenario. Well, it turns out that a computer scientist would actually wave their hands at some of these mathematical details. Indeed, we're not going to get into the habit of writing very precise mathematical formulas. What we're instead going to do is try to get a sense of the order on which the running time of an algorithm is just roughly how fast or how slow it is, but still using some symbology like n as a placeholder. And so a computer scientist would describe the running time of all three of those algorithms from week zero as being big O of n or big O of n over two or big O of log base two of n. So that means on the order of it's sort of a wave of the hand. Maybe it's n minus one. Maybe it's n plus one. Maybe it's even two n, but it's on the order of n or these other values. But in fact, to notice this chart, there's something kind of curious like these first two algorithms from week zero kind of pictorially look pretty much the same, like undoubtedly the yellow line is a little lower and therefore a little better and a little faster than the red line, but they have the same shape. In fact, I bet if we zoomed way out, these two straight lines would pretty much look identical if you change your axis to be big enough and tall enough. These would start to blur together, but clearly the green line is fundamentally different. And so this speaks to a computer scientist's tendency to not really quibble over these details like yes, the second algorithm in week zero was better. Yes, this yellow line is better, but let's just call both of those algorithms running times on the order of n. That is to say a computer scientist tends to throw away constant factors like the one half or the divided by two and they tend to focus only on the dominant factor like which value in that mathematical expression is going to grow the most, grow the fastest and n divided by two n is going to dominate over time. The bigger the phone book gets, the more pages you have. It's really n that's going to matter less so than that divided by two. And same thing over here. If you're familiar with and remember your logarithms, we don't really have to even care about the base of that logarithm. Yes, it's base two, but we can just multiply that logarithm by some other number to convert it to any base we want, base 10, base three, base seven, anything. So let's just say it's on the order of log n. So this is good because it means we're not really going to waste time getting really into the weeds mathematically when we talk about the efficiency of algorithms. It suffices to describe things really in terms of the variable n in this case, if you will, it dominates over time. And indeed, let's zoom out. If I zoom out on this picture, boom, you begin to see that, yeah, these are really starting to look almost identical. And if we kept zooming out, you would see that they're essentially one and the same. But the green one stands out. So that's indeed on the order of log of n as opposed to n itself. So here's a little cheat sheet. It turns out that within computer science and within the analysis of algorithms, we're going to tend to see some common formulas like this. So we've just seen on the order of n, we've seen on the order of log n. It turns out that very common too is going to be n times log n, maybe even n squared, and then even big O of 1. And the last of those just means that an algorithm takes wonderfully one step, or maybe two steps, maybe even 10 steps, but a constant number of steps. So that's sort of the best case scenario, at least among these options, whereas n squared is going to start to take a long time. It's going to start to feel slow because if you take any value of n and square it, that's going to imply more and more steps. So just a bit of jargon then to start off today, whereby we now have this sort of vocabulary with which to describe the running times of an algorithm in terms of this big O notation. But there's one other notation. And just as big O refers to an upper bound on running times, like how many steps maximally, how much time maximally might an algorithm take, this omega notation refers to the opposite. What's a lower bound on the running time of an algorithm? And we don't need another picture or other formulas. We can reuse the same one. So this cheat sheet here just proposes that when describing the efficiency or inefficiency of an algorithm, and you want to come up with a lower bound, like minimally, how many steps does my algorithm take? We can use the same mathematical formulas, but we can note that with omega instead of big O. So again, looks fancy, but it really just refers to a wave of the hand trying to sort of ballpark exactly what the running time is of an algorithm. And thankfully, we've seen a few algorithms already, including in that week zero. And now we're going to give it a more formal name. Linear search is what we did with that phone book first off by searching it page by page by page, looking for my phone number in that particular example. And so the difference today is that unlike us humans who can sort of look down at a phone book page and see a whole bunch of names and numbers at once, unlike a human who can look at an array on the board a moment ago and sort of see everything at once, we need to be more methodical, more deliberate today so that we can translate week zero's ideas now, not into even pseudo code, but actual C code. And so wonderfully, here at the American Repertory Theater, as we are on Harvard's campus this semester, we've been collaborating with the whole team here who are much more artistically inclined that certainly I could be on my own here. And we have these seven wonderful doors that were previously used in various theatrical shows that took place here in this theater. And we've even collaborated with the theater's prop shop who in back have wonderfully manufactured some delightful numbers and brought them to life, which is to say that behind each of these seven doors is a number. And this is going to be an opportunity now to really hammer home the point that when we want to search for some number in an array, it's pretty equivalent to having to search for a number, in this case, behind an otherwise closed door. You and I can't just look at all of these doors now and figure out where a number is, we have to be more methodical. We have to search searching these doors, maybe from left to right, maybe from right to left, maybe from the middle on out. But we need to come up with an algorithm and ultimately translate that to code. So for instance, suppose I were to search for the number zero. How could we go about searching methodically these seven wooden doors for the number zero? Let me take a suggestion from the audience. What approach might you take? What first step would you propose I take here on my own with these doors? Any recommendations? How do I begin to find myself the number zero? Florence, what do you propose? I would propose starting from the left, since zero is a smaller number. Okay, good. And hang in there with me for just a moment. Let me go ahead and start on the left as Florence proposes. Go ahead and open the door and hopefully voila. No. It's a number four. So it's not a zero. So Florence, what would you propose I do next? I probably start in the middle somewhere. If like in case, I don't know, it's going down by one. Okay, so maybe it's going down. So let me go ahead and try that. So you propose middle, I could go over here and voila. Nope. That's the number two. And I wonder where else should I look? I'm a little curious. I'm a little nervous that I ignore these doors. So Florence, if you don't mind, let's go ahead and look here. And nope, that's the number six, it seems. Let's go ahead and check in here, the number eight. So they're kind of going up and down. So Florence, how might I finish searching for this number? What remains to be done, would you say? Probably start from the right. Okay, so I could start from the right now and maybe just go over here and voila. And there it is. So we found the number zero. So let me ask Florence, what was your algorithm? How did you go about so successfully finding the number zero for us? I guess I initially tried starting by going down by one. So if the number was not at the left, then going to the center, which is halfway in between, then going to the right or there. I don't know. And playfully, how did that work out for you going to the middle? Better or worse? No different? I mean, I guess maybe it helped a little bit to then go all the way to the right. Okay, yeah, we might have gleaned some information, but let's go ahead and take a look at all of the doors for a moment. There's that four and the six again. Here's that eight again. Over in the middle, we had the two again. Over here, we have a seven for the first time. Over here, we have a five. And then of course, we have a zero. And if you took all of that in, honestly Florence, you and I, we couldn't really have done any better because these numbers, it turns out, are just really, really, really, really, randomly arranged behind these doors. So it wasn't bad at all that you kind of hopped around. Although the downside is if you hop around, you know, you and I as humans can pretty easily remember where we've been before. But if you think about how we would translate that to code, I feel like we're starting to accumulate a bunch of variables maybe because you have to keep track of that. So frankly, maybe the simplest solution, whoops, maybe the simplest solution would have been where we started in week zero, where we just take a very simple, if naive approach of starting with our array, this time of size seven behind which are some numbers. And if you don't know anything about those numbers, honestly, the best you can do is just that same linear search from week zero and just check one at a time, the values behind each of these doors and just hope that eventually you will find it. So this is already sort of taking a lot of time, right? If I do this linear search approach like I did in week zero, I'm potentially going to have to search behind all of those doors. I'm going to have to search behind all of those doors. So let's consider a little more formally exactly how I could at least implement that algorithm because I could take the approach that Florence proposed. They're just kind of jumping around and maybe using a bit of intuition. But again, that's not really an algorithm. We really need to do something more step by step. And in the meantime, let's go ahead, Joe, and let's close the curtain and see if we can't clean those up with another problem in a moment while we consider now linear search and the analysis thereof. So with linear search, I would propose that we could implement it in pseudocode first, if you will, like this, for i from zero to n minus 1. We'll see where we're going with this. If the number is behind the i-th door, return true. Otherwise, at the very end, return false. So it's a relatively simple translation into pseudocode, much like we did with the phone book some time ago. And why, though, these values? Because I'm now starting to express myself a little more like C, even though it's still pseudocode. So for i from 0 to n minus 1. So computer scientists tend to start counting from 0. If there's n doors or seven doors in this case, you want to go from 0 on up to 6 or from 0 on up to n minus 1. So this is just a very common way of setting yourself up with a for loop, maybe in C, maybe in pseudocode in this case, that just gets you from left to right, algorithmically step by step. If a condition number is behind the i-th door, i-th just being a colloquial way of saying what is behind the door at location i, go ahead and return true. I have found myself the number I want, for instance, the number 0. And then notice that this return false is not part of an else because I don't want to abort this algorithm prematurely and abort simply because a number is not behind the current door. I essentially want to wait all the way to the end of the algorithm after I've checked all indoors. And if I have still not found the number I care about, then and only then am I going to return false. So a very common programming mistake might be to nest this internally and think about things in terms of ifs and else's. But you don't need to have an else. This is kind of a catch all here at the very end. But now let's consider if this is the pseudocode for linear search, just what is the efficiency of linear search? Which is to say how well designed is this algorithm? And we gave ourselves a framework a moment ago, big O notation, which is an upper bound, which we can think of for now as meaning like a worst case. In the worst case, how many steps might it take me to find the number 0 or any number for that matter among n doors? Is it big O of n squared, big O of n times log n, big O of n, big O of log n, or big O of 1, which again just means a constant fixed number of steps. Brian, could we go ahead and pull up this question? Let me go ahead and pull it up on my screen as well. If you go to our usual URL to propose what you think an upper bound is on the running time of linear search. Okay, indeed. If we consider now the running time of linear search, it's going to be big O of n. Why is that? So in the worst case, the number I'm looking for, 0, might very well be at the end of that list, which is going to be on the order of n steps, or in this case precisely n steps. So that's one way to think about this. Well, now let me ask a follow up question proposing instead that we consider omega notation, which is a lower bound on the running time of an algorithm. Brian, could we go ahead and ask this question next at that same URL? We'll see a question asking now for the possible answers for the running time for a lower bound on the running time of linear search. So let's go ahead and take a look at this one here. And in just a moment, we'll see as the responses come in about 75 plus percent of you are proposing that it's actually omega of one. So omega is a lower bound. One refers to constant time. And why is that? Let me just take a quick answer on this point among the 75 percent of you who said one step or a constant number of steps. Why is that? How do you think about this lower bound on running time? How about from Keith? Why omega of one? Yeah, you can just open it and be lucky and find it in the first door. Yeah, so it really speaks to just that. You might just get lucky. And the number you're looking for might be at the very first door. So the lower bound, in the best case, if you will, of this algorithm, linear search might very well be omega of one for exactly that reason, that you have to get lucky. And the element might be there at the beginning. So that's pretty good. We really can't do any better than that. So we have this range now of a lower bound from omega of one on up to big O of n being upper bound on the running time of linear search. But of course, we have this other algorithm in our toolkit. And recall from week zero that we looked at binary search, although not necessarily by name. It was that divide and conquer third algorithm where we took the phone book and split it in half and half again. Now while I fumbled there, Joe kindly has given us a new set of doors. If Joe, we could go ahead and reveal our seven doors again behind which we still have some numbers. But I think this time I'm going to be a little better off Q Joe and the doors behind. There we go. So we have our same seven doors, but behind those doors now is a different arrangement of numbers. And suppose this time I want to find myself the number six. So the number six will change the problem slightly, but I'm going to give you one other ingredient this time, which is going to be key to this working. Why were Florence and I able to do no better than linear search before? Why were Florence and I able to do no better than randomly searching even last time? What was it about the array of numbers or the array of doors that did not allow me previously to use binary search? Iris, what do you think? It's because we didn't know if the numbers were sorted or not. Yeah, we didn't know if the numbers were sorted or not. And indeed barring that detail, Florence and I really couldn't have done any better than say linear search. So this time though, Joe has kindly sorted some numbers behind these doors for us. And so if I want to search for the number six, now I can begin to use a bit of that information. So you know what? I'm going to start just like we do with the phone book and start roughly in the middle and voila number five. All right. So we're pretty close. We're pretty close. But the thing about binary search recall is that this is now useful information. If the numbers are sorted behind these doors, all of the doors to the left should presumably be lower than five and all of the doors to the right should presumably be larger than five. Now I might kind of cut a corner here and be like, well, if this is five, six is probably right next door, literally. But again, algorithmically, how might we do this? We don't want to necessarily consider these special cases. So more generally, it looks like I now have an array of size three. So let me go ahead and apply that same algorithm voila to the middle. Now I have the number seven. And now it's becoming pretty clear that if the number six is present, it's probably behind this door. And indeed, if I now look at my remaining array of size one and voila in the middle, there's that number six. So this time, I only had to open up three doors instead of all seven potentially, or maybe all six doors to find my way to that number because I was given this additional ingredient of all of those numbers being sorted. So it would seem then that you can apply the better, more efficient, better designed algorithm, now known as binary search, if only someone like Joe would sort the numbers for you in advance. So let's consider now a little more algorithmically how we might implement this. So with binary search, let me propose this pseudocode. If the number is behind the middle door, return true. We found it. So if we got lucky, then we might very well have found the number six behind the middle door and we would have been done. But that didn't happen. And in the general case, that probably won't happen. So if the number is less than that behind the middle door, then just like with the phone book, I'm going to go to the left and I'm going to search the left half of the remaining doors in the array else. If the number is greater than that behind the middle door, then like the phone book, I'm going to go ahead and search the right half of the phone book. But there might still be one final case potentially, whereby if there's no doors left at all or no doors in the first place, I should at least have this one special case where I do say return false. For instance, if six for whatever reason weren't be among those doors and I were searching for it, I still need to be able to handle that situation where I can say definitively return false if I'm left with no further doors to search. So here then might be the pseudocode for this algorithm a bit more formally. Now let's consider the analysis thereof before where we left off linear search was big O of N. This time let's consider where binary search actually falls into place by asking a different question. I'm going to go ahead and go back and ask this question now. What's an upper bound on the running time of binary search? An upper bound on the running time of binary search and go ahead and buzz in if you'd like similarly to before. What's an upper bound on the running time of binary search? And you can see here answers are getting pretty dominant around log N and indeed that drives with exactly what we did in week zero. The correct answer is indeed log of N because that's going to be the maximum number of times that you can take in list or an array of a given size and split it in half and half and half until you find the number you're looking for or ultimately you don't find that number at all. Meanwhile, if we consider now not just the upper bound, we can say that the number of binary search is the lower bound on this algorithm. So in the worst case binary search takes big O of log N. Now let's consider a related question which is what's a lower bound on the running time of this same algorithm? What's a lower bound on the running time? I'll go ahead and plug this one off myself and go back to some of the suggestions thus far. In the best case maybe two you do get lucky and the number you're looking for is six or some other number is smack dab in the middle of the array and so maybe indeed you can get an array with just one step and indeed a lower bound on binary search now might very well just be an omega of one because in that best case you just get lucky and it's right where you happen to start in this case in the middle. So we seem to have a range there but strictly speaking it would seem that binary search is better. Binary search is better than linear search because as N gets big, big, big you can really feel that difference. In fact recall from week zero we played a little bit with these light bulbs and right now 64 of these light bulbs are on and let's consider for a moment just to put this into perspective how long it would take to use linear search to find one light bulb among these 64 and recall that in the worst case maybe the light bulb or the number that we're looking for is way down there at the end but we don't know it in advance and so Sumner if you wouldn't mind executing linear search on these light bulbs let's just get a feel for the efficiency or inefficiency of this algorithm. Linear search in light bulb form. So you'll notice that one light bulb at a time is going out implying that I've searched that door, search that door, search that door but we've only gotten through 10 or so bulbs and we've got another 50 plus to go and you can see that if we look inside of these doors one per second or turn off these light bulbs one per second it's going to take a long time. In fact it doesn't seem worthwhile to even wait until the very end so Sumner if you want mind let's bring all the lights back up and let's try once more another algorithm. This one binary search just to get again a feel of what the running time is of an algorithm like binary search that runs in logarithmic time so in just a moment we'll go ahead and execute binary search on these light bulbs the idea being that there's one bulb we care about let's see how fast we can get down to just one bulb out of 64 so Sumner on your marks get set go. And we're done just a few steps later and then we have this sole light bulb that was so much faster and in fact we did this deliberately one iteration at a time the algorithm that we just executed with Sumner's and that's helped algorithmically was operating what's called one hertz one hertz and if you're unfamiliar a hertz is just one something per second it's very often used in physics or just in discussions of electricity more generally and indeed in this case if you're doing one thing per second that first algorithm linear search might have taken us like 64 seconds to get all the way to that final light bulb but that second algorithm was logarithmic and so by going from 64 to 32 to 16 to 8 to 4 to 2 to 1 we get to the final result much faster even going at the same pace so in fact if you think of your computer CPU CPU's are also measured in hertz H E R T Z probably measured in gigahertz which is billions of hertz per second so your CPU the brain of your computer if it's one gigahertz that means it can literally do one billion things at a time and here we have this sort of simpler setup of just light bulbs doing one thing per second your computer can do one billion of these kinds of operations at once so just imagine therefore how much these savings tend to add up over time if you can take big bytes out of these problems at once as opposed to doing things like we did in week zero just one single step at a time. Alright well let's now go ahead and start to translate this to code we have enough tools in our toolkit in C that I think based on our discussion of arrays last week we can now actually start to build something in code on our own so I'm going to go ahead and create a file here in just a moment in CS 50 IDE called for instance numbers dot C let me go ahead and translate this to a file in C code called numbers dot C and the goal at hand is just to implement linear search in code just so that we're no longer waving our hands at the pseudo code but doing things a little more concretely so I'm going to go ahead and include CS 50 dot H I'm going to go ahead and include standard IO dot H and I'm going to start with no command line arguments like we left off last week but just with main void and I'm going to go ahead and give myself an array of numbers seven numbers just like the doors and I'm going to go ahead and say int numbers and then this is a little trick that we didn't see last week but it's handy for creating an array when you know in advance what numbers you want which I do because I'm going to mimic the doors that Joe kindly set up for us here I'm going to go ahead and say give me an array that is equal to four six eight two seven five zero and this is the feature we didn't see last week if you know in advance the numbers that you want to assign to an array you actually don't have to bother specifying the size of the array explicitly the compiler can figure that out intelligently for you but you can use these curly braces with commas inside to enumerate from left to right the values that you want to put into that array so after this line six has executed in my computer I'm going to be left with an array called numbers inside of which are seven integers listed from left to right in the computer's memory so to speak in this way now what do I want to do with these numbers well let's implement linear search linear search as we latched on to earlier as a searching from left to right or equivalently right to left but convention tends to go left to right so I'm going to do a standard for loop for int i gets zero i is less than I'm going to keep it simple for now and hard code this but we could clean this up if we want and I'm going to do i plus plus on each iteration so I'm pretty sure that my line eight will induce a for loop that iterates eight total times and what question do I want to ask on each iteration well if the numbers array at location i equals equals for instance the number I was searching for initially let's go ahead and search for zero then what do I want to do let me go ahead and print out something arbitrary but useful like found quote unquote so the human knows and then let me go ahead and just for good measure let me go ahead and return zero and we'll come back to that in just a moment but at the end of this program I'm also going to do this print F not found with a backslash and and then I'm going to go ahead and return one but before we tease apart those returns just consider the code in the aggregate here's my entire main function and on line six to recap I initialize the array just as we did very at the very beginning with a seemingly random list of numbers behind the doors then on line eight I'm going to iterate with this for loop seven total times incrementing i in each turn and then line ten just like I was opening the doors and at a time I'm going to check if the i number in this array equals equals the number I care about zero with that first demo I'm going to print found otherwise not else per se but otherwise if I go through this entire loop checking if if if if if and I never actually find zero I'm going to have this sort of catch all at the end that just says no matter what if you reach line 16 print not found and then return one now this is a bit of a subtlety but could someone remind us what's going on with the return zero on line 13 and the return one on line 17 why zero in one and why am I returning at all what problem is this solving for me even though most of our programs thus far we haven't bothered too much with this to me is it what do you think it's it's it's devate but um basically return zero is like it was executed correctly or it found it and it kind of exits that loop saying that it was like found and then return one is like the return false and it exits as well exactly and exit really is the operative word in main when you are done ready to quit the program as we've done with the word quit and some of our pseudo code in the past you can literally return a value and recall at the end of last week we introduced the fact that main always returns an inch you and I have ignored that for at least a week or two but sometimes it's useful to return an explicit value whether it's for auto grading purposes whether it's for automated testing of your code in the real world or just so it's a signal to the user that's something indeed went wrong so you can return a value from main and as Demi proposed zero means all as well and it's a little counterintuitive because thus far true tends to be a good thing but in this case zero is a good thing all is well it's success and if you return any other value for instance one that indicates that something went wrong so the reason I'm printing out after the word found I'm returning zero is so that effectively the program exits at that point I don't want to keep going again and again if I already found the number I care about and down here this one admittedly isn't strictly necessary because if I hit line 16 and maybe deleted line 17 the program is going to end anyway but there wouldn't be that so-called exit status that we discussed last week briefly whereby you can kind of signal to the computer whether something was successful or unsuccessful and the reason that zero is a good thing and one or any other number is not consider how many things can go wrong in programs that you write or that companies in the real world write when you get those error messages sometimes with those cryptic error codes there are hundreds thousands of problems that might happen in a computer program that could be that many error codes that you see on the screen reasons explaining why the program crashed or froze or the like but zero is sort of special in that it's just one value that the world has decided means success so there's only one way to get your program right in a sense but there's so many millions of ways in which things can go wrong and that's why humans have adopted that particular convention all right but let's consider now not just numbers but let's make things more interesting besides the door suppose that we actually had people's names behind them well let's go ahead and write a program this time that not only searches for numbers but instead searches for names so I'm going to go ahead and create a different file here called names dot c and I'm going to start a little similarly I'm going to include CS50 dot h at the top I'm going to include standard I.O. at the top but I'm also this time going to include string dot h which we introduced briefly last week so that we have access to stir-lang for getting the length of a string and it turns out some other functions let me go ahead and declare int main void as usual and then inside here I need some arbitrary names let's come up with seven names here and here too I can declare an array just as I did before but it doesn't have to store only ints it can store strings instead so I've changed the data type from int to string and I've changed the variable name from numbers to names and I can still use this new curly brace notation and I can give myself a name like bill and maybe Charlie and maybe Fred and maybe George and maybe Ginny and maybe Percy and lastly maybe a name like Ron and it just barely fits on my screen so with that said I now have this array of names and beyond there being an perhaps obvious pattern to them there's a second less obvious or maybe obvious pattern to them how would you describe the list of names I arbitrarily just came up with what's a useful characteristic of them? what do you notice about these names? and there's at least two right answers to this question I think what do you notice about these names? Jack? they're in alphabetical order? yes so beyond being the names of the Weasley children in Harry Potter they're also in alphabetical order and that's the more salient detail for our purposes I've had the forethought this time to sort these names in advance and if I've sorted these names that means implicitly I can use a better algorithm than linear search I can use for instance our old binary search but let's go ahead first and just search them naively for now let's still apply linear search because you know what we haven't yet done is necessarily compare strings against one another we've done a lot of comparisons of numbers like integers but what about names so let me go ahead and do this so for int I get zero just like before I less than seven I plus plus and I'm doing this only because I know in advance they're seven names I think we could probably improve the design of this code too by having a variable or a constant storing that value but I'm going to keep it simple and focus only on the new details for now and it turns out for reasons we'll explore in more detail next week it is not sufficient to do what we did before and do something like this if I'm searching for Ron it turns out that in C you can't use equals equals to compare two strings you can for an int you can for a char and we've done both of those in the past but there's a subtlety that we'll dive into in more detail next week that means you can't actually do this and this is curious because if you have prior programming experience in languages like Python or the like you can do this so in C you can't but we'll see next time why but for now it turns out that C can solve this problem and historically the way you do this is with a function so inside of the string dot H header file there is not only a declaration for sterling the length of a string like last week there's another function called stir compare and stir compare for short STR CMP allows me to pass in two strings one string that I want to compare against another string so it's not quite the same syntax indeed it's a little harder to read it's not quite as simple as equals equals but string compare if we read the documentation for it will tell us that this compares two strings and it returns one of three possible values if those two strings are equal that is identically the same letter for letter then this function is going to return zero it turns out if the first string is supposed to come before the second string alphabetically in some sense then this function is going to return a negative value if the first string is supposed to come after the second string alphabetically if you will then it's going to return a positive value so there's three possible outcomes either equal to zero or less than zero or greater than zero but you'll notice and in fact if you look at the documentation sometime it doesn't specify what value you can use to specify what value less than zero or what value greater than zero you have to just check for any negative value or any positive value and I also told a bit of a white lie a moment ago this does not check things alphabetically even though it coincidentally does sometimes and actually compare strings in what's called ASCII order or ASCII bedically which is kind of a goofy way of describing this function looks at every character in the two strings from left to right it checks the ASCII values of them and then it compares those ASCII values character by character and if the ASCII value is less than the other then it returns a negative value or vice versa so if you have for instance the letter A capital A in the string that gets converted first to 65 and then if you have an A in the other string capitalized it too gets compared to 65 and those would be equal but of course all of these names have more than one character so this ASCII order or ASCII bedacle proceeds left to right so that stir compare checks every character in the names for you and it stops when it hits that terminating null character recall that strings underneath the hood always end in C with this backslash zero or eight zero bits so that's how stir comp knows when to stop comparing values but if I go ahead and find someone like Ron let me go ahead and print out quote unquote found and like before I'll go ahead and return like Demi proposed zero just to imply that all is successful otherwise if we get all the way to the bottom of my code I'm going to print out not found to tell the story that we did not find Ron in this array even though he does happen to be there and I'm going to go ahead and return one so even though I've hard coded everything to hard code something in a program means to type it out explicitly you could imagine using a command line argument like last week to get users input who would you like to search for you could imagine using get string to get users input and ask them who would you like to search for but for now just for demonstration sake I've used only Ron's name and if I haven't made any typos let me go ahead and type in make names enter so far so good dot slash names and I will hopefully we'll see indeed found because Ron is very much in this array of seven siblings but the building blocks that are new here are again the fact that when we declare an array of some fixed size we don't strictly need to put a number here and we have this curly brace notation when we know the arrays contents in advance but perhaps lastly and most powerfully we do have this function in C called stir compare that will allow us to actually store and compare strings in this way so let me pause here and just ask if there's any questions about how we translated these ideas to code for numbers and how we translated these ideas to code for now names each time using linear search not by default. So, what's your search not binary Caleb question. Yeah, so would that program still work if Ron for example was like all caps like if you're trying to like search like if like the cases are different in terms of like application lower case. Really good question and let me propose an instinct that's useful to acquire in general when in doubt try it so I'm going to do exactly that I do happen to know the answer but suppose I didn't let me go ahead and change Ron to all caps just because maybe the human the caps lock key was on and they typed it in a little sloppily. Let me go ahead and make no other changes notice that I'm in leaving the original array alone with only a capital R. Let me remake this this program make names dot slash names and voila he's still in fact found standby. Oh, okay. Caleb you have just helped me unearth a bug that was late in the previous example none of you who should have accepted the fact that the previous program worked with Ron because I didn't practice literally what I'm preaching so Caleb hold that offer just a moment so I can rewind a little bit and fix my apparent bug so Ron was indeed found but he wasn't found because Ron was found I did something stupid here and it's perhaps all the more pedagogically appropriate now to highlight that. So how did this program say Ron was found even though this time it also says Ron was found in all caps and you know what let me get a little curious here let me go ahead and search for not even Ron how about we search for Ron's mom Molly make names. All right and now just to reveal that I really did do something stupid dot slash names okay now something's clearly wrong right I can even search for the father Arthur make names dot slash names it seems that I wrote you a program that just literally always says found so we shouldn't have accepted this is correct can anyone spot the bug based on my definition thus far. Can anyone spot the bug you know in the meantime this isn't really a bad time to open up the duck and say hello duck I am having a problem whereby my program is always printing found even when someone is not in the array and I could proceed to explain my logic to the duck but hopefully Sophia can point me at the solution even faster than the duck. We need to compare the value that we received from Staircom with something so we need to compare it with like zero and make sure that we receive the value that they're equal. Perfect so I said the right thing but I literally did not do the right thing if I want to check for equality I literally need to check the return value when comparing names bracket I against Ron to equal zero because only in the case when the return value of Staircom is zero do I actually have a match by contrast if the function returns a negative value or the function returns a positive value that means it's not a match that means that one name is supposed to come before the other or late after the other but the catch with my shorthand syntax here which is not always an incorrect syntax to use whenever you have a Boolean expression inside of which is a function call like this notice that the entirety of my Boolean expression is just a call so to speak to Staircom I'm passing in two inputs names bracket I and quote unquote Ron and therefore I'm expecting Staircom to return output so called return value that return value is going to be negative or positive or zero and in fact to be clear if the first name being searched for is bill and names bracket I or names bracket zero is bill bill comma Ron is effectively what my input is on the first iteration bill alphabetically and ask you bettically comes before Ron which means it should be returning a negative value to me and the problem with Boolean expressions is as implemented in this context is that only zero is false any other return value is by definition true or a yes answer whether it's negative one or positive one negative one million or positive one million any non zero value in a computer language like see is considered true also known as truthy any value that is zero is considered false but only that value is considered false so really I was getting lucky at first because my program was finding bill but I was confusing bill for Ron then when I did it again for Caleb and I capitalized Ron I was getting unlucky because suddenly I knew Ron capitalized wasn't in the array and yet I'm still saying he's found but that's because I didn't practice what I did. I didn't practice what I preach. Persophia is fine and so if I actually compare this against zero and now Caleb become full circle to your question I rebuild this program with make names I now do dot slash names and search for all caps Ron I should now see thankfully not found so I wish I could say that was delivered but thus is the common case of bugs so here I am 20 years later making bugs in my code so if you run up to a similar problem this week rest assured that it never gets wrong it never ends but hopefully you all have several hundred people watching you while you do your problems at this week alright any questions then beyond Caleb so great question Caleb and the answer is no it is case sensitive so it does not find Rob Ron any questions here any questions on linear search using strings now all right well let's go ahead and do one final example I think with searching but let's introduce just one other feature and this one's actually pretty cool and powerful up until now we've been using data types that just come with C or come from CS 50 like int and char and float and the like and you'll see now that there's actually sometimes reasons where you or I might want to create our own custom data types or own types that didn't exist when see itself was invented so for instance suppose that I want to represent not just a whole bunch of numbers and not just a whole bunch of names but so I'm going to show you all this bunch of names but suppose I want to implement like a full-fledged phone book a phone book of course contains both names and numbers and suppose I want to combine these two ideas together wouldn't it be nice if I could have a data structure that is a data type that has some structure to it that can actually store both at once and in fact wouldn't it be nice if C had a data type called person so that if I want to represent a person like in a phone book who has both a name and a number I can actually implement that in code but I can actually implement that in code by calling that variable of type person now of course the designers of C did not have the foresight to create a data type called person and indeed that would be a slippery slope if they had a data type for every real world entity you can think of but they did give us the capabilities to do this so if a person in our limited world here of phone books has both a name and a number we might think of it as follows a name and a number both of type string but a quick check here is a number of things but a quick check here why have I now decided somewhat presumptuously to call phone numbers strings as well we've been talking about ints behind these doors we've been searching for ints in code but why did I just presume to propose that we instead implement a phone book using strings for names and numbers any thoughts here Kurt? Yeah because we're not doing math on it it's like a phone number could be letters for all we care and in fact I mean like sometimes you see like 1-800 contacts or something like that and maybe we want to allow that Yeah absolutely a phone number despite its name isn't necessarily just a number it might be 1-800 contacts which is an English word it might have hyphens in it or dashes it might have parentheses in it it might have a plus sign for country code so there's a lot of characters that we absolutely can represent in C using strings that we couldn't represent in C using ints and so indeed even though in the real world there are these numbers that you and I talk about once in a while like phone numbers maybe in the US Social Security numbers credit card numbers those aren't necessarily values that you want to treat as actual integers and in fact those of you who did the credit problem and tried to validate credit card numbers may very well have run into challenges by using a long to represent a credit card number it probably in retrospect might very well have been easier for you to treat credit card numbers as strings the catch of course by design is that you didn't yet have strings in your vocabulary at least in C yet suppose I want to create my own custom data type that encapsulates if you will two different types of values a person shall be henceforth a name and a number it turns out that C gives us this syntax here this is the only juicy piece of new syntax besides those curly braces a moment ago that we'll see today in C type deaf and as the name rather succinctly suggests this allows you to define a type and the type will be a structure of some sort so a data structure in a programming language is typically a data type that has some structure to it what do we mean by structure it typically has one or more values inside of it so using type deaf and in turn using the struct keyword we can create our own custom types that's a structure a composition of multiple other data types so if we want to keep persons together as their own custom data type the syntax is a little cryptic here you literally do type deaf struct open curly brace then one per line you specify the data types that you want and the names that you want to give to those data types for instance name and number and then outside of the closing curly brace you literally put the word person if that's indeed the data type that you want to invent so how can we use this more powerfully well let's go ahead and do things the wrong way without this feature first so as to motivate its existence let me go ahead and save this file as phonebook dot c and let me start as always with includes cs 50 dot h and then let me go ahead and include standard io dot h and then lastly let me also include string dot h because I know I'm going to be manipulating some strings in a moment let me go ahead now and within my main pro function let me go ahead and give myself initially for the first version of this program a whole bunch of names specifically how about brian comma david we'll keep it short just so as to focus on the ideas and not the actual data therein then brian and I each have phone numbers so let's go ahead and store them in an array numbers equals again the curly braces as before and plus one six one seven four nine four nine five one thousand and indeed there's already motivation per curds comment to use strings because we've got a plus and a couple of dashes in there and then my number here so we'll do plus one nine four nine four six eight two seven five oh close curly brace semicolon so I've gone ahead and declared two arrays one called names one called numbers and I'm just going to have a sort of handshake agreement that the first name and names corresponds to the first number of numbers the second name and names corresponds to the second number in numbers you can imagine that working well so long as you don't make any mistakes and you have just the right number in each now let me go ahead and do in i equals zero i less than two I'm going to keep that hard coded for now just to do the demonstration and then inside of this loop let me go ahead and search for my phone number for instance even though I happen to be at the end so if stir compare of names bracket i equals rather comma david equals equals zero so I'm not going to make that mistake again let me go ahead inside of this loop inside of this condition here and I'm going to go ahead and do the following print out that I found for instance my number and I'm going to plug that in so numbers bracket i and then as before I'm going to go ahead and return zero and if none of this works out and i happen not to be in this array I'll go ahead and print out as before not found with a semicolon and then I'll return one arbitrarily I could return negative one I could return a million dollars negative one I could return a million negative million but human convention would typically have you go from zero to one to two to three on up if you have that many possible error conditions alright so I essentially have implemented in C a phone book of sorts right we did this verbally in the week zero now I'm doing it in code it's a limited phone book it's only got two names and two numbers but I could certainly implement this phone book by just using two arrays two parallel arrays if you will in the honor system that the first element in names lines up with the first element in numbers and so forth now hopefully if I didn't make any typos let me go ahead and make phone book alright it compiled okay dot slash phone book and it found what seems to be my number there so it seems to work correctly though I've tried to pull that one over you before but I'm pretty sure this one actually works correctly and so we found my name and in turn number but why is the design of this code not necessarily the best this is starting to get more subtle admittedly and we've seen that we can do this differently but what rubs you the wrong way about here this is another example of what we might call code smell like something's a little funky here like this might not be the best solution long term Nick what do you think yeah so what I'm guessing is that a like you know how you made the data frame before like the new data structure where the two things were like linked together in this case we're just banking on the fact that like we don't screw something up and like unintentionally like unlink them from like the same index so they're like not intrinsically linked yeah I might not be like that's exactly the right instinct in general is great as a programmer as you're maybe aspiring to be you're not all that and like you're going to make mistakes and the more you can write code you're not going to make mistakes and the more you can write code that's self-defensive that protects you from yourself the better off you're going to be the more correct your code is going to be and the more easily you're going to be able to collaborate successfully if you so choose in the real world on real world programming projects whether it's for a research project a full time job a personal project or the like generally speaking you should not trust yourself or other people that with whom you're writing code you should have as many defense mechanisms in place exactly along these lines so yes there's nothing wrong with what I have done in the sense that this is correct but as noted if you screw up and maybe you get an off by one error maybe you transpose two names or two numbers I mean imagine if you've got dozens of names and numbers hundreds of names and numbers thousands of them the odds that you you or someone messes the order up at some point is just probably going to be too too high so it would be nice then if we could sort of keep related data together this is kind of a hack to just on the honor system say my arrays line up I'm just going to make sure to keep them the same length we can do better let's keep related data together and design this a little more cleanly and I can do this by defining my own type that I'll call for instance a person so at the top of this file before Maine I'm going to go ahead and type deaf a structure inside of which are the two types of data that I care about string name and string number just as before notice though here that what I have done here is not give myself an array I've given myself one name and one number outside of this curly brace I'm going to give this data type a name which I could call person I could call it anything I want but person seems pretty reasonable in this case and now down here I'm going to go ahead and change this code a little bit I'm going to go ahead and give myself an array still but this time I'm going to give myself an array of persons and I'm going to call that array somewhat playfully people because I want to have two persons two people in this program me and Brian now I want to go ahead and populate this array that is I want to fill it with values and this syntax is a little new but it's just to enable us to actually store values inside of a structure if I want to index into this array there's nothing different from last week I do people bracket zero that's going to give me the first person variable inside so probably where Brian is supposed to go the one last piece of syntax I need is how do I go inside of that structure that person data structure and access the person's name I literally just do a dot so people bracket zero gives me the first person in the people array and then the dot means go inside of it and grab the person variable I'm going to go ahead and set that name equal to quote unquote Brian the syntax now for his name is almost identical people bracket zero dot number equals quote unquote plus one six one seven four nine five one thousand one thousand semicolon meanwhile if I want to access a location for myself I'm going to go ahead and put it location one which is the second location name will be quote unquote David and then over here I'm going to do people bracket one dot number equals quote unquote plus one nine four nine four nine four six eight two seven five oh close quote semicolon so it's a bit verbose admittedly but you could imagine if we just let our thoughts run a run ahead of ourselves here if you used get string you could sort of automatically do this if you use command line arguments maybe you could populate some of this we don't just have to hard code that is right my name and number and Brian's into this program you can imagine doing this more dynamically using some of our techniques using get string and so forth from week one but for now it's just for demonstration sake so now if I want to search this new array this new single array of people I think my for loop can stay the same and I think I can still use stir compare but now I need to go inside of not names but people and look for the dot name field so data structures have fields or variables inside of them so I'm going to use the dot notation there to go into the I person in the people array and compare that name against for instance quote unquote David and then if I have found David in this case myself go ahead and access the people array again but print out using printf the number so again the dot operator is the only new piece of syntax that's letting us go inside of this new feature known as a data structure if I go ahead and make phone book again after making those changes all as well it compiled okay and if I run dot slash phone book I now have hopefully found my number again so here is sort of a seemingly useless exercise and that all I really did was re implement the same program using more lines of code and making it more complicated but it's now better designed or it's a step toward being better designed because now I've encapsulated all inside of one variable for instance people bracket zero people bracket one all of the information we care about with respect to Brian or me or anyone else we might put into this program and indeed this is how programs this is how Google's of the world Facebook's of the world store lots of information together consider any of your social media accounts like Instagram or Facebook or Snapchat and the like you have multiple pieces of data associated with you on all of those platforms not just your username but also your password also your history of posts also your friends and followers in the like so there's a lot of information that these companies were better for worse or collecting on all of us and can you imagine if they just had one big array with all of our usernames one big array with all of our passwords one big array with all of our friends like you can imagine certainly at scale that's gotta be a bad design to just trust that you're going to get the ordering of all of these things right they don't do that they instead write code in some language that somehow encapsulates all the information related to me and Brian and you inside of some kind of stuff inside of some kind of data structure and that's what they put in their database or some other server on their back end so this encapsulation is a feature we now have in terms of C and it allows us to create our own data structures that we can then use in order to keep related data together are any questions then on data structures or more specifically type depth and struct the C keywords with which you can create your own custom types that themselves are data structures uh basley hi so is it typical to define the new data structure outside of main like the header really good question is it typical to define a new data structure outside of main quite often yes in this case it's immaterial because I only have one function in this program main but as we'll see this week and next week and onward our programs are going to start to get a little more complicated by nature of just having more features and once you have more features you probably have more functions and when you have more functions you want your data structure to be available to all of those functions and we'll so we'll begin to see definition of some of these structures being indeed outside of our own functions Peter over to you. Oh yeah would we define new classes and header files later or will we keep defining them outside of main. Really good question might we define our own types and our own data structures in header files yes eventually we'll do that too thus far you and I have only been using header files that other people wrote we've been using standard I O dot H string dot H that the authors of C created you've been using CS50 dot H with we the staff wrote it turns out you can also create your own header files your own dot H files inside of which are pieces of code that you want to share across multiple files of your own we're not quite there yet but yes Peter that would be a solution to this problem by putting it in one central place. Diego over to you. I was I was thinking this course really takes an off information to solve the upset. Because I feel there's missing formation. I am a freshman and I was taking I was so concentrated and I can't go along go ahead on the sets is there anything that I'm missing. It's a really good question in quite fair we do move quite quickly admittedly so indeed recall from week zero the fire hose metaphor that I I borrowed from MIT's water fountain indeed that's very much the case there's a lot of new syntax a lot of new ideas all at once but when it comes to the individual problems in the problem sets do realize that you should take those step by step and invariably they tend to work from less complicated to more complicated and throughout each of the lecture. So I'm going to talk about the course of the course of the course of the course of the course of the course of the course of the course of the course of the course of the course of the course and each of the examples that we do either live or by the examples that are pre made on the course's website for your review. There's always little clues or hints or examples that you can then do and certainly by way of other resources like labs and the like will you see additional building blocks as well so feel free to reach out more individually afterward happy to point you at some of those resources in fact most recently too will you notice on the course's website what we call shorts which are shorter videos made by another colleague of mine says 50 zone Doug Lloyd which are literally short videos on very specific topics so after today you'll see short videos by Doug with a different perspective on linear search on binary search and on a number of other algorithms as well. Good question Sophia back to you. I was wondering with the return values that we have for different like error cases. Would that be like what's an example of what we would use that for is that like for later if there are like several different cases and we want to somehow keep track of them. Exactly the latter so right now honestly it's kind of stupid that we're even bothering to spend time returning zero or returning one like we don't really need to do that because we're not using the information but what we're trying to do is sort of lay the foundation for more complicated programs and indeed this week and next week and beyond as your own programs get a little longer and as we the course start providing you with starter code or distribution code that is lines of code that the staff and I write that you then have to build upon. It's going to be a very useful mechanism to be able to signal that this went wrong or this other thing went wrong so all we're doing is sort of preparing for that inevitability even if right now it doesn't really seem to be scratching an itch Anthony. I'm just going to ask you really quickly obviously in this code we have Brian and your name David and that's two people so let's say we had 10 or 20 or even 30 people I know it was a question that I just wanted to clarify for myself too. And the what if being what what would change or what what's the end of that question. Yeah what would change the code or what would we do exactly to address that problem. Oh okay good question so if we were to have more names like a third name or a 10th name or the like the only things that we would have to change in this version of the program is first online 14 the size of the array so if we're going to have 10 people we need to decide in advance that we're going to have 10 people better still I could for instance allocate a constant up here so let me actually go up here just like we did in a previous class where we did something like this const in. Number and I'll just initialize this to 10 and recall that const means constant that means this variable can't change and of course means it's an integer the fact that I've capitalized it is just a human convention to make a little visually clear that this is a constant just so you don't forget but it has no functional and then this of course is just a value to assign to number then I could go down here online 16 and plug in that variable so they don't have to hard code what people would call a magic number which is just a number that appears seemingly out of nowhere now I've put all of my special numbers at the top of my file or toward the top of my file and now I'm using this variable here and then what I could do and I alluded to this only verbally before I could absolutely start hard coding in for instance Montague's name and number and Rith fix and Benedictine's name and I'm going to use this to make sure that I'm using this variable for instance I'm using this variable here. Rith fix and Benedict's and Cody's and others but honestly this seems kind of stupid if you're just hard coding all of these names and numbers and in a few weeks we'll see how you can actually store all of the same information in like a spreadsheet or what's called a CSV file comma separated values or even in a proper database which the the Facebook's and Google's of the world would use but what I could do for now is something like this for int I get zero I less than the number of people I plus plus and maybe I could do something like this. People bracket I dot name equals get string what's the name question mark and then here I could do people bracket I dot number equals get string what's their number and I can ask that question too. So now the program is getting to be a little better designed I'm not arbitrarily hard coding just me and Brian now it's dynamic and technically the phone book only supports 10 people at the moment but I could make that dynamic too. I could also call get int or like you did this past week use a command line argument and parameterize the code so that it can actually be for two people 10 people whatever you want the program can dynamically adapt to it for you. Other questions on structs on types or the like. All right so how did we get here recall that we started with this problem of searching whereby we just want to find someone in the doors we just want to find someone in the array we've sort of escalated things pretty quickly to finding not just numbers or names but now names with numbers in the form of these data structures but to do this efficiently really requires a smarter algorithm like binary search up until now we've only used in C code linear search even though recall that we did have at our disposal the pseudo code for binary search binary search we're going to need the data to be sorted and so if you want to get the speed benefits of searching more quickly by having sorted numbers somehow someone is going to have to do that for us. Joe for instance sorted behind the curtain all of these numbers for us but what algorithm did he use is going to open up a whole can of worms as to how we can sort numbers efficiently and indeed if you're the Googles and the Facebooks and the Instagrams of the world with millions billions of pieces of data in users you surely want to keep that data sorted presumably so that you can use algorithms like binary search to find information quickly when you're searching for friends or for content but let's go ahead here take a five minute break and when we come back we'll consider a few algorithms for sorting that's going to enable us to do everything we've just now discussed. So what's going on? We're going to do a few and five. All right we are back so to recap we have a couple different algorithms for searching linear search and binary search binary search is clearly the winner from all measures we've seen thus far the catches that the data needs to be sorted in advance to order to in order to apply that or to it to. I'm going to add a winner we would have added a little bit of data in there to give ourselves a working model for what it means to sort something well as always if you think of this is just another problem to be solved it's got input and output and the goal is to. Take that input and produce that output well what's the input it's going to be a whole bunch of unsorted values and the goal of course is to get sorted value so the interesting part of the process is going to be whatever there is in the middle. So I'm going to add a little bit of input because after all that's perhaps the most useful mechanism we've seen thus far to pass around a bunch of values at once using just one variable name we might have an array like this 638 52741 which seems to be indeed randomly that is unsorted and we want to turn that into an equivalent array that's just 1 2 3 4 5 6 7 8 so 8 numbers this time instead of 7 but the goal this time is not to search them per se but to sort them but before I get ahead of myself. Could someone push back on this whole intellectual exercise we're about to do with sorting in the first place like could someone make an argument as to why we might not want to bother using a sorted array why we might not want to bother sorting the elements and heck let's just use linear search to find some element whether it's a number behind a door a name in an array like when might we want to just use linear search and not bother sorting. Sophia what do you think we couldn't counter errors in sorting and that might cause errors like unpredictability in terms of like if we can find something versus linear search we know we can find it. Okay quite fair I will concede that implementing binary search not in pseudo code which we've already done but in code is actually more difficult because you have to deal with rounding especially if you've got a weird number of doors like an odd number of doors versus an even number of doors or an array of those lengths. Honestly you've got to deal with these corner cases like rounding down or rounding up because anytime you divide something by 2 you might get a fractional value or you might get a whole number so we've got to make some decisions so it's totally solvable and humans for decades have been writing code that implements binary search. It's totally possible there's libraries you can use but it's definitely more challenging and you open yourselves up to risk but let me stipulate that that's okay I am good enough at this point in my progression where I pretty sure I could implement it correctly so correctness is not my concern. What else might demotivate me from sorting an array of elements and what might motivate me to just use linear search it's so simple. Can anyone propose why Olivia what do you think? If the name of the game is efficiency and you have a small enough data set then you might as well just search it versus sort it which would be an extra expense. Yeah really well said if you've got a relatively small data set and your computer operates at a billion operations per second for instance my god who cares if your code sucks and it's a little bit slow just do it the inefficient way why because it's going to take you maybe a few minutes to implement the simpler algorithm like linear search even though it's going to take longer to run whereas it might take you tens of minutes maybe an hour or so to not only write but debug something like the fancier algorithm like binary search at which point you might have spent more time writing the code the faster code then you would have just running the slower code and I can speak to this personally back in grad school some of the research I was doing involved analysis of very large data sets and I had to write code in order to analyze this data and I could have spent hours days even writing the best designed algorithm I could to analyze the data as efficiently as possible or frankly I could write the crappy version of the code go to sleep for eight hours and my code will just produce the output I want by morning and that is a very real world reasonable trade off to make and indeed this is going to be thematic in the weeks that proceed in the course where there's going to be this trade off and quite often the trade off is going to be time or complexity or the amount of space or memory that you're using and part of the art of being a good computer scientist and intern programmer is trying to decide where the line is do you exert more effort up front to make a better faster more efficient algorithm or do you maybe cut some corners there so that you can focus your most precious resource human time on other more fundamentally challenging problems so we for the courses problems sets and labs will always prescribe what's most important but in a few weeks time with one of our problem sets will you implement your very own spell checker and among the goals of that spell checker are going to be to minimize the amount of time your code is taking to run and also to minimize the amount of space or memory that your program is taking while running and so we'll begin to appreciate those trade offs ever more but indeed it's the case and I really like Olivia's formulation of it if your data set is pretty small it's probably not worth writing the fastest best designed algorithm as possible just right at the simple way the correct way and get the answer quickly and move on but that's not going to be the case for a lot of problems there's a most problems in life if you're building Facebook or Instagram or WhatsApp or any of today's most popular services that are getting thousands millions of new pieces of data at a time you can't just linearly search all of your friends or connections on LinkedIn efficiently you can't just linearly search the billions of web pages that Google and Microsoft index in their search engines you've got to be smarter about it and undoubtedly the more successful your programs are and your code are your websites your apps whatever the case may be the more important design does come into play so indeed let's stipulate now that the goal is not to search these doors once the goal is not to search these light bulbs once the goal is not to search the phone book once but rather again and again and again and if that's going to be the case then we probably should spend a little more time and a little more complexity up front getting our code not only right but also efficient so that we can benefit from that efficiency again and again and again over time so how might we go about sorting some numbers so in fact let me see to do this if we can maybe get a hand from Brian in back Brian do you mind helping with sorting yeah absolutely so I've got eight numbers here right now that all seem to be in unsorted order yeah and Brian could you go ahead and could you sort these eight numbers for us yeah I'll put them in order so we'll take these and and all right I think these are now in sorted order yeah indeed I agree and now let's take some critique from the audience some observations with someone mind explaining how Brian just sorted those eight numbers what did Brian just do step by step in order to get to that end result the input was unsorted the output now is sorted so what did he do Peter what did you see happen he went through them step by step and if they weren't in increasing order he slipped them and yeah doing it until they were all in the correct yeah he kept step by step kind of looking for small values and moving them to the left and looking for big values and moving them to the right so effectively selecting numbers one at a time and putting it into its right place so let's see this maybe in more slow motion if you will Brian and if you could be a little more pedantic and explain exactly what you're doing I see you've already reset the numbers to their original unsorted order why don't we go ahead and start a little more methodically and could you go ahead and for us more slowly this time select the smallest value because I do think per Peter it's going to need to end up at the far left yeah sure so I'm looking at the numbers and the one is the smallest so I now have the smallest value alright so you did that really quickly but I feel like you took the liberty of being a human who can kind of have this bird's eye view of everything all at once but be a little more computer like if you could and if these eight numbers are technically an array kind of like my seven doors out here such that you can only look at one number at a time can you be even more methodical and deliberate this time in telling us how you found the smallest number to put into place sure I guess since the computer can only look at one number at a time I would start at the left side of this array and work my way through the right looking at each number one at a time so I might start with the six and say okay this right now is the smallest number I've looked at so far. But then I look at the next number and it's a three and not smaller than the six so now the three that's the smallest number I found so far so I'll remember that and keep looking. The eight is bigger than the three so I don't need to worry about that the five is bigger than three the two is smaller than the three so that now is the smallest number I found so far. But I'm not done yet so I'll keep looking the seven is bigger than the two the four is bigger than the two but the one is smaller than the two so now I've made my way all the way to the end of the array and one I can say is the smallest number that I found. Okay so what I'm hearing is you're doing all of these comparisons also similar to what Peter implied and you keep checking is this smaller is this smaller is this smaller and you're keeping track of the currently smallest number you've seen. Yeah that sounds about right. Alright so you found it and I think it belongs at the beginning so how do we put this into place now. Yeah so I want to put it at the beginning there's not really space for it so I could make space for it just by like shifting these numbers over. Okay wait wait but I feel like you're just now you're doubling the amount of work I feel like don't do all that that feels like you're going to do more steps than we need what else could we do here. Okay so the other option is it needs to go in this spot like this first spot in the array so I could just put it there but if I do that I'm going to have to take the six which is there right now and pull the six out. Alright but I think that's- The one in the right place but the six isn't. Yeah I agree but I think that's okay right because these numbers started randomly and so the six is in the wrong place anyway. I don't think we're making the problem any worse by just moving it elsewhere and indeed it's a lot faster I would think to just swap two numbers move one to the other and vice versa then shift all of those numbers in between. Yeah so I took the one out of the position at the very end of the array all the way on the right hand side so I guess I could take the six and just put it there because that's where there's an open space to put the number. Yeah and it's not exactly in the right space but again it's no worse off so I like that. Alright but now the fact that the one is in the right place and indeed you've illuminated it to indicate as much I feel like we can pretty much ignore the one henceforth and now just select the next smallest element so can you walk us through that? Yeah so I guess I'd repeat the same process I start with the three that's the smallest number I found so far and I'd keep looking the eight is bigger than the three the five is bigger than the three the two is smaller than the three so I'll remember that too that's the smallest thing I've seen so far and then I just need to check to see if there's anything smaller than the two and I look at the seven the four and the six none of those are smaller than the two so the two I can say is the next smallest number for the array. Okay and where would you put that then? That needs to go in this second spot so I'll need to pull the three out and I guess I can take the three and just put it into this open spot where there's available space. Yeah and I feel like it's starting to become clear that we're inside some kind of loop because you pretty much told the same story again but with a different number do you mind just continuing the algorithm to the end? And select the next smallest next smallest next smallest and get the sorted? Sure so we got the eight five is smaller than that three is smaller than that and then the rest of the number is seven four six those are all bigger so the three that's going to go into sorted position here and I'll take the eight and swap it. Now I'm going to look at the five eight and seven are both bigger the four is smaller than the five but the six is bigger so the four that's the smallest number I've seen so far. So the four that's going to go into place and I'll swap it with the five and now I've got the eight the seven is smaller than the eight so I'll remember that five is smaller than that but the six is bigger so the five that's going to be the next number. And now I'm left with seven eight is bigger so seven is still a small as I've seen but six is smaller so six goes next. And now I'm down to the last two and between the last two the eight and the seven the seven is smaller so the seven is going to go in this spot and at this point I've only got one number left so that number must be in sort of position. And now I would say that this is a sorted array of numbers. Nice so it definitely seems to be correct it felt a little slow but of course a computer could do this much faster than we using an actual array. If you don't mind my making an observation it looks like if we have eight numbers to begin with or N more generally it looks like you essentially did N minus one comparisons because you you kept comparing numbers again actually did N comparisons. You looked at the first number and then you compared it again and again and again at all of the other possible values in order to find the smallest elements. Yeah because for each of the numbers in the array I had to do a comparison to see is it smaller than the smallest thing that I've seen so far and if it is smaller then I needed to remember that. Yeah so in each pass you considered every number so a total of N numbers first and so you found the number one you put it in its place and that left you to be clear with N minus one numbers there after and then after that N minus two numbers N minus three numbers left out all the way down to one final number so I think this is correct and I think that's a pretty deliberate way of sorting these elements a little more deliberately than your first approach Brian which I might describe as a little more organic you kind of did it like a more like a human just kind of eyeballing things and moving things around but if we were to translate this into code recall that we have to be ever so precise and so let me consider altogether how exactly we might translate what Brian did ultimately to again pseudo code so what he did is actually an algorithm that's a name it's called selection sort why well it's sorting the elements ultimately and it's doing so by having Brian or really the computer select the smallest elements again and again and again and once you found each such small element you get the added benefit of just ignoring it indeed every time Brian lit up a number he didn't need to keep comparing it so the amount of work we he was doing was decreasing each iteration N numbers then N minus one then N minus two and minus three and so forth and so we can think about the running time of this algorithm as being manifest in its actual pseudo code so how might we define the pseudo code well let me propose that we think of it like this for I from zero to N minus one now undoubtedly this is probably the most cryptic looking line of the three lines of pseudo code on the screen but again this is the kind of thing that should become rope memory over time or just instincts with code we've seen and see how you can write a for loop for loops typically by conventions start counting at zero but if you have N elements you don't want to count up through N you want to count up to N or equivalently up through N minus one so from zero to N minus one all right now what do I want to do on the next on the first iteration find the smallest item between the ith item and the last item so this is not quite obvious I think at first glance but I do think it's a fair characterization of what Brian did because if I is initialized to zero that was like Brian pointing his left hand at the first number on the very left of the the shelf and what he then did was he found the smallest element between the ith item the first item zero and the last item so that's kind of a very fancy way of saying Brian find the smallest element among all N elements then what he did was small swap the smallest item with the ith item so we just did that switch a row so as to not have to waste time shifting everything over he instead just made room for it by swapping it with the value that was in its wrong place but now in the next iteration of this loop consider how a for loop works you do an I plus plus implicitly in pseudo code that's what's happening here so now I equals one find the smallest L item between the ith item item one zero indexed and the last item so this is a fancy way of saying Brian check all of the N elements again except for the first because now you're starting at location one instead of location zero and now the algorithm proceeds so you could write this code in different ways in English like pseudo code but this seems to be a reasonable formulation of exactly that algorithm but let's see it a little more visually now without all the switching around of the humans moving around the numbers let me go ahead and use this visualization and we'll put a link on the courses website if you'd like to play with this as well this is just someone's visualization of an array of numbers but this time rather than represent the numbers as symbols decimal digits now this person is using vertical bars like a bar chart and what this means is that a small bar is like a small number and a big bar is a big number so the goal here is to sort these bars which equivalently might as well be numbers from short bars over to tall bars left to right and I'm going to go ahead and along the top of the menu here I can choose my sorting out algorithm and the one we just described we'll call with selection sort so let me go ahead and do this and notice it takes a moment I think to wrap your mind around what's happening here but notice that this pink line is going from left to right because that's essentially what Brian was doing he was walking back and forth back and forth back and forth through that shelf of numbers looking for the next smallest number and he kept putting the smallest number over on the left where it belongs and indeed that's why in this visualization you see the small numbers beginning to be put into place on the left as we keep swooping through but notice the colored bar keeps starting later and later more right word and more right word just like Brian was not retracing his steps as soon as he lit up the numbers he left them alone and voila all of these numbers are now sorted so that's just a graphical way of thinking about the same algorithm but how efficient or inefficient was that well let's see if we can apply some numbers here but there's also ways to do this a little more intuitively over time which we'll do too so if the first time through the shelf of numbers he had eight numbers at his disposal he had a look at all eight numbers in order to decide which of these are the smallest so that's n steps initially the next time he did a pass through the shelf he ignored the brightly lit number one because it was already in place by definition of what he had already done so now he had n minus one steps to go then he did another n minus two steps then n minus three n minus four n minus five dot dot dot all the way down to the final step where he just had to find and leave alone the number eight because that was the biggest number so one single step so this is some kind of series here mathematically you might recall something like this at like the back of your math book or in high school or back at their physics textbook or the like it turns out that this actually sums up to this formula here n times n plus one divided by two and if that's not familiar you don't remember that no big deal just let me stipulate that the mathematical formula with which we began where we had the series of n plus n minus one plus n minus two plus n minus three dot dot dot simply sums up ultimately to the more succinct n times n plus one divided by two this of course if we multiply it out gives us n squared plus n divided by two and this now I will propose gives us yes this n squared divided by two plus n over two so if we really wanted to be nitpicky this is the total number of steps or operations or seconds however we want to measure Brian's running time this seems to be the precise mathematical formula therefore but at the beginning of this week we considered again the sort of big o notation with a wave of the hand we care more about the order of magnitude on which an algorithm operates I really don't care about these things divided by two and n over two because which of these factors is going to matter as n gets big the bigger the phone book gets the more doors we have the more light bulbs we have the more numbers we have on the shelf n is going to keep getting bigger and bigger and bigger and given that which is the dominant factor if we could call on someone here which of these factors n squared divided by two or n divided by two really matters in the long run as our problems get bigger and bigger as n gets bigger and bigger which of those factors mathematically dominates Anika? Oh it's Anika but it would be the n squared yeah n squared right if you take any number for n and you square it that's going to be bigger certainly in the long run than just doing n divided by two and so with our big o notation we could describe the running time of Brian's selection sort implementation as ah it's on the order of n squared yes I'm ignoring some numbers and yes if we really wanted to be nitpicky and count up every single step that Brian took yes it's n squared divided by two plus n over two but again if you think about the problem over time and n getting really large sort of Facebook size Twitter size Google size what's really going to dominate mathematically is this bigger factor here that's what's going to make the total number of steps way bigger than just those smaller order terms so in big o notation selection sort would seem to be on the order of n squared so if we consider our chart from before where we had the upper bounds on our searching algorithms both linear and binary this one unfortunately is that really the tip top of this particular list of running times and there's infinitely many more these are just a subset of the more common formulas that a computer scientist might use and think about selection sort is kind of a top the list and being number one on this list is bad n squared is certainly much slower than say big o of one which of course was constant time or one step so I wonder if we could be if we could do a little better I wonder if we could do a little better and Peter actually did say something else earlier which was about like comparing two numbers and fixing problems and if I can kind of run with that let me propose that we Brian return to you for a look at an algorithm that might be called instead bubble sort bubble sort being a different algorithm this one that tries to fix problems more locally so in fact Brian if you look at the numbers that are in front of you which you've kindly reset to their original unsorted location I feel like this one is going to be a little bit more a little bit more relevant and I think that's one of the things that I think might be called instead bubble sort bubble sort being a different algorithm this one that tries to fix problems more locally so in fact Brian if you look at the numbers that are in front of you which you've kindly reset to their original unsorted location I feel like this really if we focus on just pairs of numbers it's just a lot of small numbers like last time we tried to solve the big problem and sorting the whole thing what if we just look at pairs of numbers that are adjacent to one another to our algorithm fundamentally so for instance Brian six and three what can you what observation can you make there for us? yeah sure so six and three that's the first pair of numbers in the array and if I want the array to be sorted I want these smaller numbers to be on the left and the bigger numbers to be on the right so just looking at this pair I can tell you that the six and three are out of order the three should be on the left and the six should be on the right. so go ahead and do that and go ahead and fix that by swapping those two and just fix a small little problem and now let's repeat this process right loop seem to be omnipresent in a lot of our algorithm so six and eight is the next such pair what do you want what do you think about those? that particular pair seems okay because the six is smaller and it's already on the left side so I think I can leave this pair alone. alright how about eight and five? the eight is bigger than the five so I'm going to swap these two the five should be on the left of the eight. alright and eight and two same thing here the eight is bigger so the eight is going to be swapped with the two. alright eight and seven the eight is bigger than the seven so the eight I should switch with the seven. alright eight and four eight and four same thing eight's bigger than the four and eight and one. I can do it one last time the eight's bigger than the one and I've made that swap. and with a nice dramatic flourish if you step off to the side while not sorted in fact it doesn't really look all that much better but I do think Brian's done with the four. I do think Brian's done something smart here Brian can you speak to at least some of the marginal improvements that you've made? yeah so there are some improvements at least the one originally was all the way at the very end and it moved back one spot. and the other improvement I think is that the eight originally was way over here on the left side of the array somewhere but because the eight is the biggest number I kept switching it over and over again until it made it all the way to the end. and so now actually I think this eight is in the correct place it's the biggest number and it ended up moving its way all the way to the right side of the array. yeah and this is where this algorithm that we'll see the rest of it in just a moment gets its name bubble sort alludes to the fact that the biggest numbers start bubbling their way up to the top of or the end of the list at the right hand side of the shelf as Brian notes. but notice as Brian does to the number one only moved over one position so there's clearly more work to be done and that's obvious from the other numbers being misordered as well but we have improved things the eight is in place and one is closer to being in place so how might we proceed next? well Brian let's continue to solve some small bite size problems let's start at the beginning again three and six. sure the three and the six those seem to be in order so I'll leave those alone. six and five. six and five are out of the order so I'll go ahead and take the six and put it to the right six and two those are out of order as well so I'll swap the two in the six. six and seven six and seven are okay they're in order seven and four those are out of order so I'll switch the four in the seven. seven and one and those two are out of order as well so I'll swap those and now I think the seven has made its way to the sort of position well. so now we're making some progress seven has bubbled its way up to the top of the list stopping just before the eight whereas the one has continued its advance to its correct location so I bet Brian if we keep doing this again and again and again so long as the list remains in part unsorted I think we'll probably get to the finish line do you want to take it from here and sort the rest? yeah sure so I just repeat the process again the three and the five are okay and the two and the five are out of order so I'll swap them the five and the six those are fine as a pair the six and the four are out of order relative to each other. so I'll switch those and lists it the the six and the one those are out of order as well so I'll swap those and now the six that I can say is in its correct position and I'll repeat it again the three and the two are out of order so those get switched. the three and the five are okay the five and the four that. So that those get switched and then the five and the one need to be switched as well. so there's the five unsorted position and now I'm left with these four the two and three are okay the three and the four are okay but the four and the one are out of order. so those get switched and now the four that's in its place the two and the three are okay but the three and the one are not so I'll swap those and now the three goes into its sorted place and then finally the last pair to consider is just the two and the one those are out of order so I'll swap those and now the two is in place and one is the only remaining number so I can say that that one's in place too and now I think we have a sorted array again. Nice so it felt like this was a fundamentally different approach but we still got to the same endpoint so that really now invites the question is to whether bubble sort was better or worse or maybe no different but notice too that we've solved the same problem fundamentally differently the first time we took the more human natural intuition of just find the smallest element alright do it again do it again do it again this time we sort of viewed the problem through a different lens and we thought about it would seem what does it mean for the list to be unsorted and as Peter noted it's when things are out of order like that very basic primitive where something is out of order suggests an opportunity to solve the problem that way just fix all of the tiny bite sized problems and it would seem that using a loop if we repeat that intuition it's going to pay off eventually by fixing fixing fixing fixing all of the little problems until the big one itself would seem to go away well let me return to the visualization from before re-randomize the bars short bar is small number big bar is big number and let me go ahead and run the bubble sort algorithm this time with this visualization and you'll notice now sweeping from left to right are two colored bars that represent the comparison of two adjacent numbers again and again and again and you'll see this time that the bars are being a little smart and they're not going all of the time and they're not going all the way to the end every time just like Brian illuminated the numbers and stopped looking at the eight and the seven and the six once they were in place but he and this visualization do indeed keep returning to the beginning doing another pass another pass and another pass so if we think ahead to the analysis of this algorithm it sort of invites us to consider well how many total comparisons are there this time it would seem that the very first time through the bars or equivalently the very first time through the shelf Brian in this visualization did like n minus one comparison so n minus one comparisons from left to right out of n elements you can compare n minus one adjacencies after that it was n minus two n minus three n minus four n minus five until just two or one remains and at that point you're done so even though this algorithm fundamentally took a different approach and achieved the same goal it sorted the elements successfully let's consider how it was implemented in code and whether it's actually a little bit more whether it's actually a little faster or a little slower and let's set one final bar in fact two earlier we considered only the upper bound on selection sort just so that we have something to compare this again so let's also consider for a moment what the running time is of selection sort in terms of a lower bound best case scenario with selection sort if you have n elements and you keep looking for the next smallest elements again and again and again it turns out that selection sort is not really our friend here's for instance the chart of where we left off in terms of omega and notation before linear search and binary search could very well get lucky and take just one step if you happen to open a door and voila the number you're looking for is already there but with selection sort as we've implemented it both with brian and with the visualization unfortunately it's none so good with the lower bound why well brian pretty naively every time he searched for a number started the left started the left and went all the way to the right started the left one all the way to the right to be fair he did ignore the numbers that were already in place so we didn't keep looking at the one he didn't keep looking at the two once they were in place but he did keep repeating himself again and again touching those numbers multiple times each so again even though you and I the humans could look at those numbers and be like obviously there's the one obviously there's the two obviously there's the three brian had to do it much more methodically and in fact even if that list of numbers were perfectly sorted he would have wasted just as much time in fact brian if you don't mind could you quickly sort all eight numbers again brian if we start with a sorted list this is kind of a nice perversion to consider if you will when analyzing an algorithm sometimes you want to consider best cases and worst cases and there would seem to be nothing better than heck the list is already sorted you got lucky there's really no work to be done the worst cases the list is maybe completely backwards and that's a huge amount of work to be done unfortunately selection sort doesn't really optimize for that lucky case where they're already sorted so brian I see you've re sorted the numbers for us from left to right if we were to re execute selection sort as before how would you go about finding the smallest number are Heatless numbers but should it be the smallest number so we decided earlier that to find the smallest number I need to look at all the numbers from left to right in the array and each time check to see if I found something smaller so I would start with the one that's the smallest thing I've seen so far I have to keep looking because maybe there's a zero or a negative number later on I need to check to see if there's anything smaller so I would check the two is bigger the three four five six seven eight they're all bigger so it turns out I was right all along the one was the smallest number and it's already in place so now that number is in place and then to find the next smallest number what would you have done I would do the same thing two is the smallest number I've found so far and then I would look through all the rest to see if there's anything smaller than the two and I would look at three four five six seven eight nothing smaller than the two so I'd go back to the two and say okay that number must now be in its sorted position indeed and that story would be the same for the three for the four the for the five like nowhere in selection sort pseudo code or actual code is there any sort of intelligence of if the numbers are already sorted quit like there was no opportunity to short circuit and abort that algorithm earlier Brian would literally be doing the same work whether they're all sorted from the get go or completely unsorted and even backwards and so selection sort doesn't really perform very highly so now we're hoping bubble sort indeed does so toward that end let's take a look at some proposed pseudo code for bubble sort assuming that the input is is anything whether sorted or unsorted the pseudo codes always going to look like this repeat repeat until sorted for I from zero to n minus two now what does this mean zero to n minus one goes from the first element to the last so zero to n minus two goes from the first element to the second to last why am I doing that we'll see in just a moment the condition inside of this loop is if the ith and the ith plus one elements are out of order swap them so this is me being a little clever if you think about all of these numbers is being in an array or behind doors if you iterate from zero to n minus two that's like going from the first door to the second to last door but that's good because my condition is checking door I and I plus one so if I start at the beginning here and I only iterate up to this door that's a good thing because when I compare door I and I plus one at the very end I'm going to compare door I and I plus one what I don't want to do is to make sure I'm going to do this I'm going to compare door I and I plus one what I don't want to do is compare this door I against door I plus one which doesn't even exist and indeed that's going to be an error that probably all of you make at some point going beyond the boundary of an array touching memory that is going one or more spaces too far in the array even though you didn't allocate memory for it so this hedges against that possibility so this would seem to be a pretty smart algorithm but as written it's not actually as performant as might be ideal with bubble sort suppose the list were entirely sorted Brian not to make you a sort and resort numbers too many times do you mind giving us a sorted list one more time real quick? In a moment I want to see if we consider that same sorted list as before this time with bubble sort can we do fundamentally better? I have this code saying repeat until sorted so how might this change so Brian you've got the sorted numbers again this should be a good case but selection sort did not benefit from this input even though we could have gotten lucky bubble sort what would your thought process be here? So the thought process for bubble sort was to go through each of the pairs one at a time and see if I need to make a swap for that particular pair so I'd look at the one and the two if those two are okay I don't need to swap them the two and the three are okay I don't need to make a swap there the three and the four are okay the four and the five are okay same with the five and the six and the six and the seven and the seven and the eight so I made it with my way through all the entire array and I never needed to make any swap because every pair that I looked at they were already in the correct order relative to each other indeed and so it would be foolish and so obvious this time if Brian literally retrace those steps and did it again with n-1 elements and then did it again with n-2 elements I mean if he didn't do any work any swaps the first pass he's literally wasting his own time by even doing another pass or another pass and so that's kind of implicit in the pseudocode this repeat until sorted even though it doesn't translate perfectly into a for loop or a while loop in C it kind of says intuitively what he should do repeat until sorted Brian has already identified the fact by nature of him not having made any swaps that this list is sorted therefore he can just stop and this loop does not have to continue again and again we can map this to C like code a little more explicitly we can by default say do the following n-1 times because among n elements you can look at n-1 total pairs from left to right without going too far but notice I can add an additional line of code here which might say if no swaps quit from the algorithm altogether so so long as Brian is keeping track of how many swaps he made or didn't make through one pass as with a variable called counter or whatever he can simply abort this algorithm early and certainly then save us some time so with that said let's consider for just a moment with the running time of bubble sort might be in terms of an upper bound in the worst case if you will well in the case of bubble sort notice with the pseudocode where we're doing something n-1 times and inside of that we're doing something n-1 times so again repeat n-1 times literally says do the following n-1 times the for loop here which is just a different way in pseudocode of expressing a similar idea but giving us a variable this time for i from 0 to n-1 n-2 is a total number of n-1 comparisons so this is an n-1 thing inside the repeat and an n-1 outside the repeat so I think what that gives me is n-1 times n-1 times so now if I just kind of foil this sort of in high school or middle school math n-2-1n-1n plus 1 we can combine like terms n-2n plus 1 but per our discussion earlier this is really getting into the weeds who cares about the 2n or the 1 the dominant factor as n gets large is definitely going to be the n-2 so it would seem that bubble sort if you actually do out the math in the formulas is going to have an upper bound of n-2 or rather on the order of n-2 steps so in that sense it is equivalent to selection sort it is no better fundamentally it's what we would say asymptotically equivalent that is as n gets really large this formula is for all intents and purposes equivalent to the selection sort formula even though they differed slightly in terms of their lower order terms for all intents and purposes they are on the order of n-2 both but if we consider a lower bound perhaps even though bubble sort has this same upper bound running time if we consider a lower bound as with this smarter code where brian might actually have the wherewithal to notice wait a minute I didn't do any swaps I'm just going to exit out of this looping pre much early not even prematurely but early because it would be fruitless to keep doing more and more work we can then whittle down this running time I think not quite as good as omega of 1 which was constant time like you cannot conclude definitively that an array is sorted unless you minimally look at all of the elements once so constant time is completely naive and unrealistic you can't look at one element or two or three and say yes this is sorted you've got to obviously look at all of the elements at least once so this would seem to suggest that the omega notation for that is the lower bound on bubble sorts running time if we're clever and don't retrace our steps unnecessarily is in omega of n or technically it's n-1 steps right because if you've got n elements and you compare these two these two these two these two that's n-1 total comparison but who cares about the minus one it's on the order of n or omega of n notation here so to recap selection sort selects the next smallest elements again and again and again unfortunately based on how it's implemented in pseudo code and actual code it's in big O of n squared but it's also an omega of n squared which means it's always going to take the same amount of time asymptotically that is as n gets large unfortunately too bubble sort is no better it would seem in terms of the upper bound it's going to take as many as n squared steps too but it's at least marginally better when it comes to using something like an input that's already sorted it can self-short circuit and not waste time but honestly n squared is bad like n squared is really going to add up quickly if you've got n squared and n is a million or n is a billion I mean my god that's a lot of zeros that's a lot of steps in the total running time of your algorithm can we do better can we do better and it turns out we can and we'll consider one final algorithm today that does fundamentally better just like in week zero we sort of latched onto binary search and again today as just fundamentally better than linear search by an order of magnitude so to speak it's picture representation was fundamentally different I think we can do fundamentally better than bubble sort and selection sort and so while both bubble sort and selection sort might be the sort of thing that I was using in grad school just to rip up the code quickly and then go to sleep it's not going to work well for very large data sets and frankly it wouldn't have worked well if I didn't want to just sleep through the problem rather we want to do things as efficiently as we can from the get go and let me propose that we leverage a technique and this is a technique that you can use in almost any programming language see among them known as recursion and recursion quite simply is the ability for a function to call itself up until now we have not seen any examples of this we've seen functions calling other functions main keeps calling printf main has started to call sterling main called stir comp compare earlier today but we've never seen main called main and people don't do that so that's not going to solve a problem but we can implement our own functions and have our own functions call themselves now this would seem to be a bad idea and principle if a function calls itself my god where does it end it would seem to just do something forever and then something bad probably happens and it could and that's the danger of using recursion you can screw it up easily but it's also a very powerful technique because it allows us to think about potential solutions to problems and a very interesting and dare say elegant way so we're not only going to be able to achieve correctness but all of these things are going to be a little bit more and we're also better design because of better efficiency it would seem here so let me propose this recall this code from week zero which was the pseudo code for finding someone in a phone book and recall that among the features of this pseudo code were these lines here go back to line three and we describe those in week zero as being representative of loops programming construct that has something happen again and again you know what there's a missed opportunity here in this pseudo code to use a technique known as recursion this implementation is what we call iterative it is purely loop based it tells me literally go back to this line go back to this line go back to this line there's no calling yourself but what if I changed week zero pseudo code to be a little more like this let me go ahead and get rid of not just that one line but two lines in both of those conditions let me quite simply say instead of open to the middle of the left half of the book and then go back to line three or open to the middle of the right half of the book and then go back to line three why don't I just more elegantly say search left half of book search right half of book now immediately I can shorten the code a little bit but I claim that by just saying search left half of book and search right half of book I claim that this is enough information to implement the very same algorithm but it's not using a loop per se it's going to induce me the cumin or me the computer to do something again and again but there's other ways to do things again and again not by way of a for loop or a while loop or a do while loop or a repeat block or a forever block you can actually use recursion and recursion again is this technique where a function can call itself and if we consider after all the pseudo code we are looking at is the pseudo code for searching and on line seven and nine now I am literally saying search left half of book and search right half of book this is already even in pseudo code form an example of recursion here I have in eleven lines of code an algorithm or a function that searches a phone book in line seven and nine I have on the lines of code that literally say search a phone book but more specifically search half of the phone book and that's where recursion really works its magic it would be foolish and incorrect and completely counterproductive to just have a function call itself with the same input with the same input with the same input because you'd have to be kind of crazy to expect different output if the input is constantly the same but that's not what we did in week zero and that's not what we're doing now if you use the same function or equivalently algorithm but change the input to be smaller and smaller and smaller it's probably okay that a function is calling itself so long as you have at least one line of code in there that very intelligently says if you're out of doors if you're out of phone book pages quit you need to have a so called base case you need some line of code that's going to notice wait a minute there's no more problem to be solved quit now and so how can we map this to actual code let's consider something very familiar from week one recall when you reconstructed one of Mario's pyramids looked a little something like this and let's consider that this is a pyramid of blocks of bricks that's of height four why four while there's one then two then three then four bricks from top to bottom so the total height here is four but let me ask the question a little naively how do you go about creating or how do you go about printing a pyramid of height four well it turns out that this simple Mario pyramid that's ever more clear if we get rid of the unnecessary background is a recursive structure of some sort it's a recursive physical structure why well notice that this structure this brick this pyramid is kind of defined in terms of itself why well how do you make a pyramid of height four I would argue a little obnoxiously a little circularly well you create a pyramid of height three and then you add an additional row of bricks alright well let's continue that logic alright fine how do you build a pyramid of height three well you sort of smile and say well you build a pyramid of height two and then you add one more layer alright fine how do you build a pyramid of height two well you build a pyramid of height one and then you add one more layer well how do you build a pyramid of height one what you just put the stupid like brick down you have a base case where you sort of state the obvious and just do something once you hard code the logic but notice what's kind of mind bending or kind of obnoxious in a human interaction like you're just defining the answer in terms of itself I keep saying the same thing but that's okay because the pyramid keeps getting smaller and smaller and smaller and so I can handle that one special case and so you can do this just for fun the brick down and so here's where things kind of bottom out and it's no longer a cyclical argument you eventually just do some actual work but in my mind I have to remember all of the instructions you just gave me or I gave myself I had to build a pyramid of height four no three no two no one now I'm actually doing that so here's the pyramid of height one how do I now build the pyramid of height two well, rewind in the story to build a pyramid of height two you build a pyramid of height one and then you add one more layer. So I think to add one more layer I essentially need to do this alright now I have a pyramid of height two but wait a minute the story began with how do I build a pyramid of height three well you take a pyramid of height two which I have here and you add an additional layer so I've got to build this additional layer I'm going to go ahead and give myself the layer the layer and then I'm going to put the original pyramid of height two on top of it and well lots of pyramid of height three now well how did I get here well let me keep a room with my hands. Winding in the story the very first question I asked myself was how do you build a pyramid of height four well the answer was build a pyramid of height three great that's done then add one additional layer and if I had more hands I could do this a little more elegantly but let me go ahead and just lay this out here's the new level of height three and now I'm going to go with four now I'm going to go and put the pyramid of height three on top of it until voila I have this form here of Mario's pyramid. So it's a bit cyclical in that every time I asked myself to build a pyramid of a certain height I kind of punted and said no build a pyramid of this height no build a pyramid of this height no build a pyramid of this height but the magic of that algorithm was that there was constantly this do a little more work build a layer do a little more work build a layer and it's in that implicit building of layer after layer after layer that the pyramid itself the end goal actually emerges. So you could implement the same thing with a for loop or a while loop and frankly you did it was a slightly different shape for problems at one but you did the same thing using a loop and you kind of had to do it that way at least as we prescribed it because with print death you have to print from the top of the screen to the bottom like we haven't shown you a tech yik yet to sort of print a layer and then go back on top. So I'm kind of taking some real world liberties here by lifting these things up and moving them around you have to be a little more clever in code but the idea is the same and so even physical objects like this can have some recursive definition to them. And so we present this sort of goofy example because this notion of recursion is sort of a fundamental programming technique that you can leverage now to solve problems in a fundamentally different way and I think for this we need one final visualization of merge sort with both Brian's help in the computers and merge sort is going to be an algorithm whose pseudo code is there say the simplest we've seen thus far but deceptively simple the pseudo code for merge sort quite simply is this sort the left half of numbers sort the right half of numbers merge the sorted halves and notice even at first glance this feels kind of unfair like here's an algorithm for sorting and yet I'm literally using the word sort in my algorithm for sorting it's like in English if you're asked to define a word and you literally use the word in the definition like that rarely flies because you're just sort of making a circular circular argument but in code it's okay so long as there's one special step that's doing something a little differently and so long as the problem keeps getting smaller and smaller and smaller and indeed it is. This pseudo code is not saying sort the numbers sort the numbers sort the numbers know it's dividing the problem in half and then solving the other half as well so it's shrinking the problem on each iteration now I will disclaim we're going to need that so called base case again I'm going to have to do something stupid but necessary and say if there's only one number quit it's sorted that's the so called base case the recursive case is where the function calls itself but this is indeed our third and final sorting algorithm called merge sort and we'll focus here really on the juiciest pieces one this notion of merging so in fact Brian can we cut over to you just so we can define before we look at the merge sort algorithm itself what do we even mean when we say merge sorted half so for instance Brian has on his shelf here two arrays of size four in the first array on the left are for integers 3568 and in the right side in another array of size four. Is our four numbers two one two four seven notice both the left is sorted and the right is sorted but now Brian I would like you to merge these sorted halves tell us what that means sure so if I have a left half that sorted from smallest to largest and have a right half that's also sorted from smallest to largest I want to merge them into a new list that has all of the same numbers also from smallest to largest and I guess where I could start here is that the smallest number of the combined array is the smallest number of the combined array. Needs to begin with either the smallest number of the left half or the smallest number of the right half because on the left the smallest number is the three and on the right the smallest number is the one one of those two has got to be the smallest number for the entire array and between the three and the one the one is smaller so I would take that one and that's going to be the first number the smallest number of the merged two halves. And then I guess I would repeat the process again on the left side the smallest number is the three on on the right side the smallest number is the two and between the three and the two the two is smaller so I would take the two and that's going to be the next number. So I'm slowly building up this sorted array that is the result of combining these two now I'm comparing the three on the left to the four on the right between the three and the four the three is smaller so take the three and we'll put that one into position. Now I'm comparing the five on the left with the four on the right between the five and the four of the four is smaller so that one goes into position and now I'm comparing the five on the left with the seven on the right the five is smaller so the five goes next next. I'm comparing the six on the left with the seven on the right the six is still smaller so that one is going to go next. Now I'm comparing the eight and the seven the only two numbers left the seven is the smaller between the two so I'll take the seven and put that into place and now I'm only left with one number that hasn't been put into the merging of the two have and that's the number eight so that number is going to take up the final position. And now I've taken these two have each of which was originally sorted and made one complete array that has all of those numbers in sort of order. Indeed and consider what we've done we've essentially verbally and physically kind of defined a helper function our own custom function if you will whereby Brian has defined what does it mean to merge to arrays specifically merge to sorted arrays because why well that's a building block that I think we're going to want in this merge sort algorithm so just like in actual C code you might have defined a function that does some small task so have we now verbally and physically defined the notion of merging the mind bending part here is that sort left half of numbers and sort right half of numbers is kind of already implemented. There's nothing more for Brian or me to define all that remains is for us to execute this algorithm focusing especially on these three highlighted lines of code and let me disclaim that of the algorithms we've looked at thus far odds are this will be the one that doesn't really sink in as quickly as the others even if the others might have taken you a moment a day a week to settle in or maybe you're still not quite there yet that's fine merge sort is a bit of a mind bending one because it seems to sort of work magically but it really just works more intelligently and you'll begin to get more comfortable with harnessing these kinds of primitives so that we can ultimately indeed solve problems were efficiently so Brian has kindly put the numbers again on the top shelf and he has put them into their original unsorted order just like for selection sort and bubble sort and Brian I'd like to propose now that we execute this merge sort algorithm and if you don't mind all recite allowed at first the few steps. So here is one array of size eight with unsorted numbers the goal is to sort these numbers using merge sort and recall that merge sort essentially is just three steps sort left half sort right half merge sorted halves. So Brian looking at those numbers there could you go ahead and sort the left half of numbers. All right so there are eight numbers the left half would be these four numbers so I will sort those except I'm not really sure how do I now sort these four numbers. Yeah so granted we've seen selection sort we've seen bubble sort but we want to regress to those older slower algorithms Brian I can kind of be a little clever here while I'm giving you a sorting algorithm so now you effectively have a smaller problem in array of size four and I'm pretty sure we can use the same algorithm merge sort by sorting left half sorting right half and then merging the sorting half sorted half so could you go ahead and sort the left half of these four numbers. All right so I have these four numbers I want to sort the left half that's these two numbers so now I need to figure out how to sort two numbers. All right now us with human intuition might obviously know what we have to do here but again let's apply the algorithm sort left half sort right half merge sorted halves Brian could you sort the right half of this array of size two. So I got the array of two so I'll first sort the left half of the array of two which is the six and this is where the base case in white on the slide comes into play if only one number quit so Brian I can let you off the hook that list of size one with the number six is sorted. So that's step one of three done Brian could you sort the right half of that array of size two. The right half is the number three there's also just one number so that one is done. Good so think about where we are in the story we've sorted the left half and we've sorted the right half even though it looks like neither Brian nor I have done any useful work yet but now the magic happens Brian you now have two arrays of size one could you merge them together. All right so I'm going to merge these two together between the six and the three the three is smaller so that one I'll put there first and then I'll take the six and that one goes next and now I have a sorted array of size two that is now done. This is where you now need to start remembering step by step sort of in your brain is the thing is pile up how did we get to this point we started with a list of size eight. We then looked at the left half which is an array of size four we then looked at the left half of that which was an array of size two then two arrays of size one then we merge those two sorted half so I think now if I rewind in that story Brian you need to sort the right half of the left half of the original numbers. All right so the left half was these four the right half of the left half is now going to be these two numbers and so now to sort those two I guess I would repeat the process again look at numbers individually I would look at the left half of these two which is the eight that one's done and the five that one's done as well. All right so step three of three then is merge those two sorted halves. So between the eight and the five the five is smaller so that one will go in first and then the eight will go after that and now have a second array of size two that is also now sorted. Indeed so here's where you can you have to remind and rewind in your mind's eye. We've just now sorted the left half and we've sorted the left half and the right half of the left half so I think the third and final step at this part of the story is Brian to merge those sorted halves each of which now is the right half of the left half of the left half of the left half. So I think the third and final step at this part of the story is Brian to merge those sorted halves each of which now is of size two. All right I have two arrays of size two each of which is sorted that I need to merge them so I'm going to compare the smallest numbers from each I'm going to compare the three and the five the three is smaller so that one will go in first. Now between these two arrays I have a six and a five to compare the five is smaller so that one I go next. Between the six and the eight the six is smaller and I'm left with just the eight so we go back to the original story of eight numbers that I was sorting. I think I have now sorted the left half of the left four numbers from that original array. Indeed so if you're playing along at home think about you've got all these thoughts probably kind of piling up in your mind that's indeed supposed to be the case and admittedly it's hard to keep track of all of that so we'll let Brian now execute this all together doing the same thing now by sorting the right half all the way to completion Brian if you could. All right so the right half we got four numbers I'm going to start by sorting the left half of the right half which is these two numbers here. To do that I'll repeat the same process sort the left half of these two numbers which is just the two that one's done if only one number. Same thing with the right half the seven is only one number so it's done and now I'll merge the sorted halves together between the two and the seven the two is smaller and then the seven. So here now is the left half of the right half an array of size two that is sorted and I'll do the same thing with the right half of the right half starting with the left half which is four that's done the one is done and now to merge these two together I'll compare them and say the one is smaller. So I'll put the one down and then the four. So now I have two sorted arrays each of size two that I now need to backtrack and emerge together to form an array of size four. So I'll compare the two and the one between those two the one is smaller then I'll compare the two with the four the two is smaller then I'll compare the seven with the four the four is smaller and then finally I'll just take the seven the last number and put that in the final spot. And so now from the original array of eight numbers I've now sorted the left half and I've sorted the right half. And now that's doing us to our third and very final step could you Brian merge the sorted halves. Yeah and I think this is actually an example we've seen already and what I'm going to do in order to sort these two halves is just take the smaller number from each half and compare them again and again. So between the three and the one the one that's the smallest number so that goes into place then between the three and the two the two is smaller. So we'll take that and put that into place. Now I'm comparing the three with the four so three that goes next next I'm comparing the five with the four the four are smaller. So the four goes into place next now I'm comparing the five with the seven the five is smaller so that one goes into place. I'm next comparing the six with the seven so the six is smaller that goes next and now I'm left with two numbers the eight and the seven the seven is the smaller of the two. So that one goes next and at this point I only have one number left which is the eight and so that one's going to go into its sorted position at the end of the array. So even though it felt like we weren't really doing anything it's several points in that story it all sort of came together when we started merging and merging and merging these lists and it's not an accident that Brian was using multiple shelves moving the numbers from top to bottom to make clear just how many times he was effectively dividing that list up. We started with a list of eight and we essentially took it to two lists of size four four lists of size two eight lists of size one and while it wasn't exactly in that order if you rewind and analyze all of the steps that's indeed what he did. He went from eight to two fours to four twos to eight ones and that's why he moved those numbers from the top shelf down three times from eight to fours to twos to one. So how many times did he move the numbers he moved them three times total and on each of those shelves how many numbers did he have to merge together on each of those shelves he ultimately touched all eight numbers. He first inserted the smallest number then the second smallest then the third smallest but unlike selection sort he had smartly already sorted those halves. So he was just plucking them off one at a time he wasn't going back and forth back and forth he was constantly taking from the beginning of each of those half lists. So on every shelf he was doing let's say n steps because he was merging in all n elements of that shelf but how many times did he merge n elements together. Well he did that three total times but if you think about binary search and really the process of divide and conquer more generally anytime you divide something in half and half and half. As he was doing from eight to fours to twos to ones that's a logarithm that's log base two and indeed that is wonderfully the height of this shelf. If you have eight elements on the shelf the number of additional shelves Brian used three is exactly what you get by doing the math log base two of eight which is to say Brian did n things log n times. And again with a wave of the hand computer scientists don't bother mentioning the base with big O notation it suffices just to say log n Brian did n things log n times. And so if we consider then the asymptotic complexity of this algorithm that is to say the running time of this algorithm in terms of big O notation notice that it performs strictly better than selection sort and bubble sort n times log n. And even again if you're a little rusty on logarithms log n we have seen as of week zero in binary search is definitely faster than n steps. So n squared is n times n. And log n is n times log n which is indeed mathematically better than n squared. As with merge sort though if we consider the lower bound notice that bubble sort yes goddesses low as omega event turns out merge sort is a little bit like selection sort in that way. So we have a selection sort in that it doesn't optimize itself and get your out of the algorithm early it's always n log n so it's lower bound omega of n log n and that might not be acceptable sometimes you might have certain data inputs where maybe it tends to be sorted and you don't want to waste time so maybe you'd be okay with bubble sort but honestly as n gets large the probability that the input to your sorting algorithm is just by chance going to be sorted is probably so so low. That you're just better off in the general case using an algorithm like merge sort that's n log n always. We can see this visually using our bars too and notice just as Brian was dividing and conquering the problem in half and half and half and then reconstituting the array by merging those halves you can kind of see that visually here. There's a lot more going on and it's going to seem in a moment that everything just kind of magically worked but you can see in the faded purple bars that indeed this is sorting things in halves and then merging those halves together. And this visualization was a little different it did not have the luxury of three shelves it just moved top to bottom top to bottom and honestly Brian could have been a little more optimal there. We wanted to make clear how many total shelves there were but honestly there's no reason he couldn't have just moved them numbers down then back up then back down then back up and indeed that's the price you pay with merge sort even though n log n is better than n squared and ergo merge sort is arguably better than selection sort and bubble sort you pay a price and this speaks to the trade off I mentioned earlier. Almost always when you do something better in code or solve a problem more intelligently you have paid a price maybe you spent more time as the human writing the code because it was harder and took more sophistication that is a cost maybe you had to use actually more space Brian had to have at least one extra shelf in order to implement merge sort if implementing merge sort in code and see you will need at least a second array to temporarily put the numbers into and then you have to use the number of the numbers in the code. As you merge things back and forth if you want to be extravagant you can have three separate arrays or four separate arrays but it suffices per the graphical representation of merge sort to just use a second array now that might not seem like such a big deal but implicitly you need twice as much space and that might be a big deal if you've got a million things to sort and you now need to arrays that's two million chunks of memory that you need and maybe that's not tenable so there too there's going to be a trade off and maybe while slower selection sort of bubble sort maybe it's better because it's a little more efficient with space it's going to depend on what you care about and what you want to optimize for and honestly money is sometimes a factor in the real world maybe it's better to write slightly slower code so that you don't have to buy twice as many servers or twice as much memory for your computer it depends there on what resource is more important your time the computers time your your your wallet or some other resource altogether so we'll continue to see these kinds of trade offs. But perhaps the most mind-blowing thing we can do as we wrap up here share a few visualizations of how these algorithms actually compare and one last piece of jargon is this one final Greek symbol theta it turns out that thanks to selection sort and merge sort we can actually apply one more term of art here this theta notation any time an algorithm has both the same upper bound as its lower bound running time you can actually use this one final Greek symbol. So we can actually describe it in just one sentence instead of two in terms of theta notation so because selection sort was in both big O event squared and omega event squared you can actually just say it's in theta event squared it's always n squared either in the upper bound or in the lower bound same thing for merge sort it's in theta of n log n we cannot use theta for bubble sort or for binary search or for linear search because they had different upper and lower bound. Let's go ahead now and prepare a final demonstration this time using some random inputs so you'll see here a video comparing selection sort bubble sort and merge sort all together all three of them start with random data but let's just see what it means for an algorithm to be an n squared in the worst case or an n log n in this case instead. Selection sort's on the top bubble sort's on the bottom merge sort's in the middle and would you believe it merge sort is already done. And meanwhile we have some very trendy music we can listen to which is really just there to distract us from the fact that how slow n squared actually is in practice and notice there's not that many bars here there's maybe like a hundred or so bars like n is a hundred that's not even a big value when we're talking about the Twitter is the Facebook. The Google's of the world these are trivial sizes and yet my God we're still waiting for selection sort and bubble sort to finish. And so you can see here that it really matters when you exercise a little bit more cleverness and you leverage more efficient algorithm and finally selection sort is done bubble sort's still taking a little longer here and this is going to depend on the input sometimes you can get lucky or unlucky but I think it's convincing that merge sort has one in this case.
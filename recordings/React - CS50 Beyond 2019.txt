 Okay, let's get started. Welcome back everyone to CS50 Beyond. So for a little bit of context from where we've been so far, thus far in CS50 Beyond, we've mostly been building on a lot of the topics that we saw in CS50. We saw HTML, we saw CSS, we saw JavaScript, we saw SQL, and we've been taking those ideas so far this weekend just building onto them, showing you some additional features, some more advanced capabilities, building some more sophisticated applications. Today, we're really going to introduce something entirely new, that being React, which is a JavaScript library built by Facebook, which is designed to make it very easy to build interactive and dynamic user interfaces. React is going to be a totally different way of thinking about how to build web applications and how to build user interfaces, and we'll go through a bunch of examples to give you a sense for how this works, how to think in React, and ultimately how to program in React. And so React has a couple of key concepts, a couple of key ideas that you want to be thinking about. And the first of those ideas is that React is a declarative way of programming. And so thus far in most of what we've done in CS50 and in programming more generally, we've been doing what you might call imperative programming. In imperative programming, we write code that tells the web application what to do. We want to insert this thing into the web page. We want to manipulate the web page in this particular way. But whereas imperative programming is a model where we say this is what we want the web application to do, declarative programming is a style of programming where we say this is what we want the web application to look like. This is how the application should look, and we're going to let React take care of figuring out what the application should do in order to make the application look like the way that we want it to look. You'll see in a moment what that actually means and what that actually looks like. So that's the idea of declarative programming. And in order to achieve that goal, there are a number of tools that React is going to use. The first of which is that instead of using JavaScript, it's going to use a slight extension to JavaScript, a variant on JavaScript that has a few more features called JSX or JavaScript X. And the idea of JSX is whereas in JavaScript, we have a whole bunch of different types of values. We have integers and we have strings. We even have functions and arrays and so forth. In JSX, we can treat HTML elements as values of their own. So in JSX, you might see code that looks something like this, cause some variable name equals and then like an H1 block, for instance. Like HTML code that can be a value in JavaScript that we can assign to a variable, that we can loop over at some point potentially, that we can do calculations and computations on. This sort of code is common in JSX and has some special meaning. So that's something that we'll see in React in just a moment. And so in order to make this work, there are a couple of libraries that we're going to need. I'll just briefly describe what they are and then we'll actually start using them. React is going to be the library that's going to actually allow us to do the building of these user interfaces. There's a separate but related library called React DOM that's going to take care of taking the React components that we create, more on components in just a moment, and actually inserting them into the web page, into the DOM, the document object model. And then finally, we're going to be using a package called Babel. And we're using this because most web browsers, in fact all of our modern web browsers, don't understand JSX code natively. So code that looks like this, Chrome and Safari don't normally know how to understand this code and figure out what it means. So what we need to do is translate this sort of code into regular JavaScript code that our browsers can understand and Babel is going to take care of doing that translation for us, such that the browsers can actually understand the code that we're using. So in a moment in our HTML pages, in the head section where we might include JavaScript, we're going to be including a whole bunch of scripts. One for React, one for React DOM, one for Babel, you can just copy these scripts and put them in the top of your HTML page, and you'll see in a moment how that will eventually become useful. So all of React is really designed around this idea of components. When we're going to think about our web application, we're going to try and divide the application into the components that make it up and then start to analyze how is that component going to behave. And a component is going to end up looking a little something like this. Like if we wanted a component that was just going to say hello, we're going to find a class called hello in JavaScript and extends React.component is basically just saying that this hello class is a React component. And what do we do from there? Well, each React component needs to have some notion of what does it look like when I render this component to the screen. When I try and take this component and display it on my web page, what should show up? Declaratively, what is going to show up on the page? And so every component is going to need a render function. And that render function is just going to describe what it is that this component looks like. And in this case, this hello component, very simply inside of its render function, is just going to return a JSX element, some HTML like code, that it's just a heading that in this case says hello. So we've defined a React component. This is our first React component. And all it does is display an H1 tag. So I'll show you that right now. We'll actually build our very first React application. So I'll go into a code editor, create a new file. I'll call it hello.html. All the source code examples for today are already online if you want to take a look at them. So let's say doc type HTML, HTML. In the header section of the website, I'm going to need to include those JavaScript libraries. I need to include React and React, DOM and Babel. And so I'll go ahead and go back to these libraries. I can just copy these scripts, paste them into the page. And all right, I'll give this a title as well. We'll just call it hello. And now in the body of the application, I need to create a space inside the body of the application where my React application is going to live. So I'm just going to create a div, some vertical section of my page where I'm going to insert my application, whose ID is going to be app. And it's just going to be an empty div. Nothing inside of it. This is where my, I'm not add app. This is where my application is going to go. And now let me add some JavaScript code, some React, some JSX code that's going to render a React component inside of my web page. So I'm going to use a script tag, but I'm going to use a special type attribute. The type is going to be text slash babble. What this is basically going to say is that this is not regular JavaScript. This is JSX, that special version of JavaScript that I mentioned a moment ago. And the fact that I'm labeling it with type text slash babble is going to tell babble the package that, okay, this is JavaScript code that I'm going to need to translate into regular JavaScript before the browser is going to be able to understand it. So when we open the page, babble is going to first take the step of translating it for us so that Chrome or Safari or whatever browser you're using can actually understand this code. So now let me go ahead and define my first React component. So we're going to call it class hello extends react dot component. So I've created a React component. And remember the one thing that every component needs is a function called render that's going to say what should this component look like when I render it to the screen. So I'll define a function called render. And what this function render is going to do is it's going to return something and it's going to return let's say in H1 tags the word hello. Sorry, this return statement, I've enclosed the whole thing in parentheses just in case I need the HTML to span multiple lines. Not really necessary in this case, but you'll see this pretty commonly as you begin to build larger and larger components. So all the hello classes doing right now is defining a component that describes what it should look like when it's on the screen. Questions so far? All right, the next step and really the last step of building this particular application is just saying I actually want to render this component on the screen. And so in order to do that, we're going to use react DOM, which is that library that lets us take react components and put them into the DOM into our page. And we're going to say react DOM dot render. And react DOM dot render takes two arguments. The first argument is what is the component that we want to render? And the component we want to render is hello. And now you can treat hello just like you would treat any other HTML element, for example. I'm just going to say hello as though it were in HTML tag like div or H1 or some other tag. Because I have defined it as a component. And so now I can just say I want to render the hello component in my page. And where on the page do I want to render it? Well, I want to render it here. In other words, the section of the body that has ID app. And as we've been doing previously in the week, if I want to get it, that particular part of the page, I can just say document dot query selector. Pound app to say get the thing that has ID app and insert this hello component into the page there. So I'll show you what it looks like, assuming this all works. And then we'll go back to the code. I'll open up hello.html. And all right. It just says hello. It displays that it as an H1 tag. And the way it did that is because I took this hello component and rendered it into the DOM. So in 28 lines of code, we've defined our first React application. What questions do you have? All right. So let's move on a little bit. Look at some more things that we can do here. So we have this class called hello. This React component. And once I have a React component, I can reuse that component. I can use it multiple times if I wanted to do different things. And so let me define a new React component. I'll call it app that's going to extend React component. And the render function of this app is just going to say, when you render this application, go ahead and render a div inside of which are two hello components. You can nest components within each other, so to speak. So inside of my app now, I'm saying, let's render two hello components, one after the other. And inside the DOM, let's go ahead and just render the app component. So I'm rendering the app component. And what does the app component do? It renders two hello components. And each hello component is just going to say hello. I refresh the page. And OK. Now I have two hello components that are displayed on the page. Questions about anything so far? Go back to the code so you can take a look at it. All right. So this is the basics of what React is about, defining these components, and then defining what the page should look like, and then letting that render. Though so far, all we've done is render something that we could have done much more easily with just HTML and no JavaScript. So let's take a look now at what we want to happen if we want different components to behave differently. Maybe I don't just want hello to say just the word hello. Maybe I wanted to say hello to a particular person, for example. And so maybe I would like to add some attributes, or what we're going to call props, or properties, to these components. And so I want to say hello to a particular person. I'll pass an argument or a prop to this hello component, name being a Josh, for example, and another prop where the name is Athena. And maybe I want more hello components, one where the name is Julia, and one where the name is Krishna, and we'll do one more for Andrew. So now I've got five different hello components, each of which I'm providing some different information. I'm providing in a name a prop into the hello component. And now inside the hello component, I'm going to use that information. Rather than just say hello, I'm going to say hello to whatever the name is. And so in JSX, this type of syntax, if I want to plug in some value here, I'm just going to use curly braces. And in order to get it at this component, props, and get at the name property of those props, I'm going to say this.props.name. So the hello component says hello. And then in curly braces, let's plug in this.props.name, get the name property of this component, and plug it in there. And then my application is just going to render a whole bunch of hello components, each of which is provided with a different name prop. So I go ahead and refresh the page, and all right, great. I see five different components, each of which now behaves differently based upon what properties it was initially provided with. Questions about anything so far? Yeah? Could you use Ginger inside the instance inside one of these components? Could you use Ginger? So Ginger is a templating language. You couldn't use Ginger in just this HTML page, because you'd need some sort of renderer that actually processes Ginger. But you could imagine combining Flask and React together, and there are certainly ways to do that if you wanted to. Other things? Yeah? What's the name of this property? Yes, name was just an arbitrary choice. You can create props of any name that you want. You can call them whatever you want so long as you're consistent. The only thing that matters is that this name of the prop here matches up with this name here so that I can reference the correct property. Yeah? Yeah? OK. So, first, you like to play the components with the way. And then that way that way. But, but, but, just a new thing. I guess, OK, do you have a class book? So then, within that, you're returning to name, you're referring to the drop that you created in class app. But it's not app, you're referencing the whole property. Yeah, so the way to think about it, the good question, so the way to think about it is the hello component, what I have here between lines 13 and 22, is a component that says hello. And it's saying hello to a particular person. And the way that it's doing that is it's going to draw on its properties. When I define the hello component here, I don't yet know what those properties are. So I'm just saying whatever those properties are, plug in the name here, even if I don't know the name yet. I don't actually use the hello component until inside of this, inside of my app, where inside of the app, I'm saying put a hello component here, and in particular put a hello component here who has a name property equal to Josh, for example. It's the way that that's working. Yeah? And you're very beginning with both examples, you use the line of the property, we have to draw on both sides, and that would probably be needed to play to the last class. Why do you not need to play the same format inside of the app to get the name to the last class? So why do I not need a second React DOM dot render inside of the app class? I only need the React DOM dot render function in order to insert a component into the DOM. So I want to insert into the DOM at this section of the page, the div that has an idea of app. I want to insert the app component, but the app component itself contains the hello components already, so I don't need to tell the hello components where to go. When I render the app component, that will implicitly render all of the components that are within it. Yeah? Can you set default values for properties? And did you just divide a name for the property one? If you didn't provide a name, sure, certainly. So if I wanted to have some sort of default, if I have this dot props dot name and there is no property called name, then the value of this dot props dot name is going to be like a special value, like undefined in JavaScript. And so a common way in JavaScript to get it some sort of default is by saying this dot props dot name, or two vertical bars meaning or, and then in quotation marks I can have whatever I want the default name to be. And so maybe the default name is going to be Andrew. And now even if I don't include name on this last one, just say hello, assuming all goes right. Okay, it still says hello Andrew on the last iteration of the page. And the reason that works is when I say this dot props dot name or Andrew, if this dot props dot name has a value, then this expression will short circuit, so to speak. It will just use this dot props dot name because it already is a value. But if this dot props dot name is undefined, then it's going to go to the thing on the other side of the or expression and say, okay, let's go see the other thing. And now in that case is Andrew in this case. Question. Can you have a bunch of or expressions? Yes, this shouldn't be any reason why not. Other things. Okay, so how do we feel about this much so far? Do we need more examples of this stuff or do we want to move on? Sure, so let's see another example. In this case, let's try an example that is also going to say hello that will add an additional feature to it in just a moment. So we're going to have a hello component that is just going to say hello, for example. And let's go ahead and just return the hello component. So all app is going to do this component is return a hello component. And all the hello component is going to do is return in each one that says hello, for example. So, okay, this is just going to say hello and that's all it's going to say. Let me now add to this hello component. Instead of just returning in each one, let me wrap this whole thing inside of a div. Let me also add a button that says click here. So, all right, I have hello and I have a button that says click here. And I got that by just saying inside the hello component, you should have in each one that says hello. And you should also have a button that says click here. Now, once we have this button, we can begin to add functionality and features to this component. So I could say button on click equals something. I can type in the name of a function here for what function should run when this button is clicked on. And so I could say like this dot, and I'll just call it handle click, is a pretty conventional name for what should happen when the button is clicked on. Again, using curly braces to mean plug in some JavaScript here. And now I can say, okay, handle click is going to be a function using the arrow syntax for the function. And this function right now is just going to alert and say hi. So let's try this. We'll just refresh this page. We have a hello in each one and a button that says click here. When I click here, I get an alert and that alert says hi. Again, how did that work? Inside of the hello component, we have an each one tag that just says hello. And then a button. And when we click on that button, we're going to run this dot handle click. In other words, the handle click function or method of this class, this class called hello. Here is that handle click function. And all it's going to do is display an alert that says hi. Questions about any of that so far? All right, we'll slowly build up into more sophisticated things. What? Oh, question, yeah. Yeah. So the same way we named one like the line below, here we named it kind of call the app. We just hit the button. Like handle click to be defined as function. It really, whatever we like call hello, yes, you can in addition to just providing it before. So before we said hello, name equals like Krishna, for example, and we provided a string in as the value of the property name. You could if you wanted to provide in like a function like this dot some function and provide some function into the components of the different components use different functions to behave in different ways. That's something you can do as well. We may see an example of that later. Yeah. The line at the this line. So this line is just taking this component that we've written and actually inserting it into the application. So as of this point, all I've done is define this is what an app should look like and how it should behave. But I haven't actually taken that app and put it into my web page. It's not until line 40 here that I actually say take this app component and actually insert it into whatever the thing that has ID app is and actually putting that into the web application. Yes, in this case app is has a hello component inside of it. You could imagine that we probably don't need it because this app component is just rendering the hello component. So I could replace this with just hello. But it doesn't matter in this case. They're sort of interchangeable. Yeah. Yeah. Why does that handle clip? Is that? Is that the function? So why is there? Is it app? What is that? This is referring to this component. In other words, this hello component and the hello component currently has two functions inside of it. A render function or method and then handle click. And so we're saying run this handle click method when the button is clicked on. Yeah. How would you pass an. How would you pass an. Oh, you can access this dot props dot whatever from inside of your functions as well. So if we still had a name property, you could say hi, this. Hi, and then you could add on this dot props dot name, for example, you could access the properties from inside of the functions. Yeah. So is the. We had hello. Yep. So this is just referring to the hello component. And it's and Java and react is automatically going to fill in props with any of the properties that are passed into the hello component. So so long as you provide attributes in this style of name of the component and then name equals something name is automatically going to become one of the props and its value in this case is going to be Julia. Other things before we go on. Yeah. It could be. Yeah, it could be any JavaScript value. Yeah. Yeah. You could define it differently, although the arrow function syntax is going to. It adds a couple little nuances. It's going to make sure that it handles the this binding correctly. It's going to make sure JavaScript is a little bit funky about it the way it handles the keyword this and what the keyword this means. And so to be safe, most of the time for event handlers, you'll want to define it this way. No need to worry too much about that, though. Yeah. Yes, in fact, in most production environments, what you'll really do is separate each component into a different file into a different JavaScript file and then you'll just combine them all together. Yeah. So in actuality, what most people will do, and we'll probably take a look at this tomorrow, is that rather than have the page translate all of the JSX into JavaScript every single time, usually what people will do is they'll write the JavaScript JSX code once and then before they actually push their code to the Internet, they'll compile the code into regular JavaScript and then deploy that such that it is plain JavaScript that any browser can understand. And that just works for efficiency reasons so that you don't need to keep recompiling the code every single time because the recompiled code is going to be the same. But we'll take a look at that tomorrow. All right. So so far, all we've done is come up with a lot of JavaScript syntax to do what would have been pretty easy to do with just HTML. So let's now actually take a look at why it is that React is going to give us additional is going to make it easier to actually write certain types of applications as opposed to just more wordy, which it seems to have been so far. And the main reason that it's going to be helpful is when it comes to thinking about state and the state of our application. So so far, when we've been building applications, we've been writing things imperatively. When you were writing your quiz application, for instance, you change the variable referring to what question number you're currently on in the quiz. And then you had to actually say, all right, let's update the page. Now, let's update the DOM to actually use this new question or when you change the score for the game, for instance, you actually had to say, all right, let's now update the page to take this variable relating to the score and put it into the web application. What we're going to do with react with declarative programming is say on this page, we're going to have this part of the page just draw information from whatever our data is. So all we have to do in order to update the page is just change the data, change the state of the application and the view of the application, what the application looks like is going to change to reflect that. And so let's do a simple example of that. We're going to define a class that's going to count, much like we did a JavaScript example before, whereby we would have a counter that is going to just count when you click a button that says increment, increment, increment. What we're going to do is we're going to find some application state. And the initial state, we need to define when we first create the component. And in Python, we did this via a function called underscore underscore in it, the constructor function for what happens when you first create a new Python object. JavaScript has something very similar. It also has a constructor function. It's actually called constructor. And the constructor takes as its arguments, props, all of the properties that the component is going to be. A component is going to have. And there's one line here that has to do with object oriented programming because the counter class, this component is extending the regular react component. We need to add the special line called super props. Again, don't worry too much about this, but in long story short of this line is we're basically saying the reacts code for how a component works needs to use those props. And so we'll go ahead and provide it to what's called the super class, which is react component. Again, no need to worry too much about that line. It just needs to be at the top of your constructor every single time. The interesting part of the constructor is that the constructor is where we're going to define the state of the application. Like what it is that this component needs to keep track of. So this stop state, we're going to set equal to some JavaScript objects, some collection of key value pairs. It's going to represent the state of the object or the state of this particular component. And so the counter, all it needs to do is keep track of some variable that's going to keep track of what the current count value is. So we can start by having this dot state have a key called count and a value of zero. Basically just saying that this component is going to start off by displaying a zero, for example. So I'll show you that in practice so that it hopefully becomes a little bit clearer. I'll go ahead and create a new file. We'll call it counter dot html. And I'll go ahead and take all this code, put it back in here at least for now. And instead of rendering a hello component, I'm going to render a counter component. And all right. What is the counter component going to do? Well, inside of the constructor, again, super props just to make sure the constructor works okay. We're going to define the state of the application. And the state of the application is going to have a count of zero to start with. This is the starting value of this particular piece of the state of my counter. And now what is my render function going to do? Well, the render function is going to return a div. And inside of which is going to just be this dot state dot count. So in order to access the state of my component, I can say something like this dot state dot count. And that's going to insert the current state's count value into my application at this point. If I open up counter dot html, all right, great. I see the number zero because that's the current value of the state in JavaScript. Questions about that so far? Yeah. I think I'm going to go ahead and talk about this. Props is specific to, it's a special name in React syntax. Yeah, this is specific to JavaScript, props is specific to React, but they both are special names. It doesn't drop, so like our drop in general more like keyword arguments and type of stuff. Yeah, you can give them keyword arguments. That's a good comparison. Other things? Yeah. Sure. The semicolons are usually optional in JavaScript, so most of the time it's not going to matter whether you include the semicolons or not. I'll generally defer to using the semicolons most of the time, they'll occasionally forget one. Other things? Okay, so notice now that I can change the value of the count variable in the state object, and that's going to change the page. If I change count to one, for example, and refresh the page, the page changes in response to that state. But of course, what I'd really like to do is to add some code such that this component will modify its own state. So let me go ahead and take this.state.count, put that inside of an H1 tag, and add a button called increment. And when I click the button on click, let's go ahead and run the this.increment function, which is a function that I'm going to write. Here's my increment function. And what I would like to do, what you think might be the easiest thing to do is just to say like this.state.count. If I want to increment it, let's just for simplicity sake, say change it to one, you might think I would say something like this. This.state.count. equals one, and that would be nice to say, but unfortunately react is a little bit more complicated than that. React does not let you modify the state directly. And the reason for that is react is going to be smart about things. It doesn't want to reload parts of the page if it doesn't need to for efficiency reasons. And so if you want to modify the state of the application, you need to use a special function called this.setState. This.setState is a function that's going to take a JavaScript object, and it's going to let me change the state of the application. So if I want to change it to have a count of one, for example, this would be the code that I would use. If I want to change the state to have a count of one, I call this.setState, passing in a JavaScript object, setting count equal to one. I'll show you what that looks like, and then we'll go back to the code. Refresh the page. It says zero, and I have a button called increment. And if I click the increment button, okay, the zero changed to one. I didn't have to say go into the H1 tag and get rid of the zero and replace it with a one. All I did was initially I said inside of the H1 tag, let's go ahead and have whatever the value of this.state.count is. And if I ever change the state, as if I are calling this.setState, that's going to change the value of this.state.count, and that's going to result in a different value being inserted into the H1 tag there. Question. If you are in the short state, what's the more you use it in? And use that state to address how is it updated? Or do you have to let things like this state for all of the other characters that are there? Oh, good question. So the question is, what if my state were more complicated? In addition to having count, I also have some other attribute one that's equal to high and some other attribute two that's equal to buy. Like what happens to attribute one and attribute two? If I call setState count goes to one. Any key that's not included in the setState object is just going to remain unchanged. So all setState is doing here is it's going to set count equal to one. But anything else in the state, if I didn't mention it explicitly, is just going to stay as is. So you don't need to worry about resetting those same values to the same things again. You just need to say, what is it about the state that I want to change and put that into setState? Yes. That state could be out of new key to state? Want to know what state is? In setState could you add a new key to your state? You probably could, but probably not a good idea too. Any state you want, you probably want to give it an initial value inside of the stop state. Yes? In 3S and instructions, I was wondering if there's no other person like you mentioned, like we're not writing the DOM that's going to go in and take the chair or move the chair or something else that is reacting to that somewhere else or is it like a button? Yes. So React is taking care of the process of actually updating the DOM whenever it needs to, but it's handling that logic. And so all we need to worry about is what the page should look like and React does the heavy lifting of figuring out what to insert and what to remove from the DOM. And the advantage here is that it makes sure that our data and our user interface stay in sync. That it's possible in the quiz application, if there were a bug in your quiz application, that you could have your variables not be consistent with what it is the user is seeing on the screen, React is going to make sure that those things always line up. So it eliminates a large class of potential bugs that you could have in your application. Yeah? Why do you have to talk to state? Okay, what's the difference between state and props? Props you can think of as attributes that you're going to provide into your component and the component never changes its own props. There's sort of information you provide to the component about how that component should behave and the component will never change its own props. State is something that a component has that the component might change at some point in the future. So something like the name that we're saying hello to, assuming we never want the hello component to change who it's saying hello to, that should be a prop. But if it's something like the counter where the counter component is going to change the value of the count, that should be part of the application's state. Yeah? Can the initial value of the state be dependent on props? Can the initial... Can the initial... Can the initial... Can the initial... Yes, you could make the initial state dependent upon the props. You can do that. Alright, so this application doesn't quite work just yet because right now it says 1 and I click increment and it stays at 1 because all I'm doing right now on the increment is setting count equal to 1. So of course the simple way to actually do the increment would be to set count equal to what? Count plus 1 and count is located inside of this dot state. So I could say this dot state dot count plus 1. Would be one way to do that. So I set the count equal to whatever the current count is plus 1. I refresh the page, okay, now it's 0. I click increment and increments to 1. I click again. And every time the state of the application is changing and the number is going to increment as a result. And so you can do that as much as you want to do by calling this dot set state, updating the state to be whatever you want the new value to be. Questions? So small little nuance for if you actually want to really want to start building react applications that are larger in scale. In general, this is considered poor design to set the state and reference this dot state inside of the set state function. Reason being if you have multiple things happening simultaneously, it's possible that to this dot set state calls might be happening at a similar time and you might end up with a race condition, something similar to what we described yesterday with sequel where someone else might modify the value of this dot state dot count before we have an opportunity to actually run this function. And so in practice react recommends that if ever your new state is going to depend on your previous state, then you should actually change this dot set state. So this dot set state has a couple of possibilities. It can take just a JavaScript object describing what the new state should be, but it can also take as its argument a function from the old state to the new state. So I could say this dot set state is going to be a function that takes a cold old state to be explicit. A function from old state to and then in parentheses. The new state where count is going to be old state dot count plus one. Usually this is just called state and not old state, but I'm calling it old state for clarity. This is going to do basically the same thing that our previous code did, but it's a little bit more secure by providing a function that says here's how you translate the old state to the new state. Just take the old state count and add one to it that avoids against the possibility of race conditions. So you'll see me do this from time to time through the examples and just know that I'm doing that for security purposes, just to prevent against potential bugs, but that's a small nuance of the way it works. Yeah. Why is it necessary to, or what is the difference between differentiation and state? If you're writing this count as count and then having to further you it by the old state or this dot state or something like that. And why are those two terms different? So this count on the left hand side is just the key of a JavaScript object. So it's much in the same way that when I was defining state up here count was just the name of the key of the object that I'm assigning to a particular value. Whereas if I want to actually reference the current value of count, there is no variable just called count. It's stored inside of this dot state. So to be able to access count, I need to use this dot state dot count. But if I'm just have some JavaScript object, I can have a key in that object that is called count. It's the difference there. Yeah. Why is old state like this is not old state. This is just a function and set state reacts logic is going to take care of automatically saying if I provide a function to set state, it's going to pass the current state into that function. And then we're just going to calculate the new state based on that. React react handles this part of it for us by taking this function and providing the current state to it as the argument to that function so that when it's calculating what it should set the new state to, it's going to say, all right, given this current state, let me pass it to this function. And whatever comes back should be the updates that I need to make to the new state. I'll leave it up here if you want to keep looking at it. Yeah, another question. In fact, normally it's just called state, but for clarity, I called it old states that would be a little bit clear. Yeah. You could just chain dots together. If you have some key that is equal to some object and some key inside that, you could continue to chain that. Yeah. Why do you pass the function to that state? So the reason this is going to prevent race conditions is because JavaScript or the react will make sure that when it's calling set state, it's going to provide it with the current value of the state. And that's going to give it a new state. And if there's some other set state function happening elsewhere, potentially concurrently, it will make sure that they don't interfere with each other as opposed to if we were just referencing this dot state, that count. If that line was taking a long time, there could potentially be interferences there that are happening. Yeah. On the, like, race conditions issue, is it, does this only do, like, on one page, does people have a common student who uses looking at the same page, are going to switch states? Like, this would be just another common thing. Right. This is something else on the same page that could be happening concurrently. This is a simple example, so it's not really ever going to happen. You can imagine more complex examples where that could be a problem. Okay. Just for a sake of example, let's go ahead and try and extend this to add a decrement button to decrease the value of the count. So, button that says decrement. When I click it, on click, we'll do this dot decrement. And what decrement is going to be is a function that sets the state of the application. Taking the old state and saying, okay, the new count should be whatever state that count was minus one. Add a semicolon there. So, all right. I now have an increment button that increases the value of the count and a decrement button that decreases the value of the count, each working just by changing the contents of this dot state by calling the this dot set state function. Yes. Can we instantiate multiple of these? If I add another counter here and why not? I'll add a third counter. We can reuse components as much as we want. And each component has its own state inside of it. So, this component's count state is going to be entirely independent of this component's count state, and it's going to be entirely independent of this once. Questions? Yeah. If you wanted to use this value, you would then just be able to access the state of the component, assuming you're inside of that component. And you can reference that state to be able to do something with it. And we'll see an example of that in just a moment when we try and build something a little bit larger. All right. Let's go ahead and try a bit of a larger example. Are there any other questions about the basic ideas of what's going on here so far? Hopefully to become clearer as we begin working with it too. All right. What we're going to do now is build a game. And this is going to be a game that I used to use with my younger brother when he was growing up starting to learn addition, where we would just show him like addition questions like three plus five and you'd have to type in an answer. And if you get the answer right, you get some points for it. I will implement a graphical web based version of that sort of game. And so I'll go ahead and create a new file, call it addition dot HTML. We'll start with the same contents as hello for now. And all right. So what is our application going to do? We don't need a hello component anymore. We'll change the title of hello to addition, for example. And let's go ahead and create this application. We'll keep this there. A lot of constructor. And so let me show you for a moment what the final game should look like. And then we can think about, okay, what state do we need to keep track of in order to make this work. And so let me go into. All right. This is what this game ultimately is going to look like. It's going to show us an addition problem. You type in the answer, you get it right. The score increases. You get it wrong. And oops. You get it wrong and the score stays the same. So I get it right and I keep adding to my score. And I get it wrong and the score doesn't change. All right. So given that, that's the way we want the application to behave. What needs to be in the state of this application? Like what are the things I need to keep track of here? What changes about this application is one way to think about this. There are multiple things. Yeah. So the question that's being shown, sure, and the question that's being shown has two parts. It has num one, which is going to be some number. We'll maybe start it with one. And it has num two, a second number. It's also will start it off as one. Now these are going to change. So great. The numbers that are shown on the screen, this plus that, those are parts of the state because we might want to change that part of the state. What else is part of the state of this application? Yeah. The current score. Great. The score is part of the state and that's just going to be zero for now. Anything else you can think of? Yeah. Yeah. The answer, like the thing that I'm currently typing in in the input field, in the response field, that's also going to be part of the state as well. So I'll go ahead and add response and just set that equal to the empty string because initially I haven't typed in anything at all. So great. Here's some basic components that are going to make up the state of this application. And let's go ahead and render this application. We're going to render a div and maybe in an H1 just for now. We'll go ahead and have the addition problem here. This dot state dot num one plus this dot state dot num two. That's going to be the question that I'm ultimately going to ask is just this plus that. If I open up addition dot HTML. All right. Great. I see an addition problem where I'm drawing the numbers from the state later. If I change the state and change those numbers, this page will change automatically. And now in addition to that, I'm also going to need. An input field in input field whose value is going to be this dot state dot response. In other words, whatever the user has currently typed in. Questions about that. All right. So now I have a place where I can ask a question and a place where I can type an answer. And now if I actually try and type an answer, something sort of strange happens, but it'll make sense if you think about what's actually happening in my code and what I've written. If I try and press like to, for example, to answer to, I press to. But okay, nothing showed up in the text field. I can keep pressing whatever keys I want to on the keyboard and nothing's showing up in the text field. And I can use it to say, yeah, exactly, it's a state. And this input field right now, I'm saying it's value is this dot state dot response. And this dot state dot response is never changing. And so what's in the input field is always going to be empty. It's never going to have anything else there. So what I need to do is actually add some code to say what should happen when I actually like change the value of the input field. So the input field has a property called on change. And I'm going to say when you change the input field, let's call a function. And I'm just going to call it like update response. So this dot update response is going to be a function that's going to handle when I type something into the input field. Okay, so here's update response. It's going to be a function that function. All functions that are event handlers can take as argument their event. And we're going to need this in just a moment and you'll see why. Because what I want to do is I want to update the state, this dot set state. And I want to set the response to event dot target dot value. And event dot target dot value is nothing specific to react. So I'm going to say this is just a JavaScript for saying here's the event, the event of changing the input field. The events target is what triggered the event, the input field in particular. And what is the current value of the input field meaning what it is that I've typed into the input field. I'm going to update the response to be that. So what have I done here? I've said on this input field, whenever it changes, call the update response function. And the update response function is going to set the state of my application, updating the current value of response. And so if I press refresh now, now I can actually type numbers in here. I can add two, three, whatever number I want. If I scroll back here, you can actually see what I'm doing here. If I say current guess is, and then let me fill in this dot state dot response, just like plug in whatever this dot state dot response is right now. If I refresh the page and I start typing like two current guesses to eight current guesses, twenty eight to current guesses to empty. The US goes empty. The page is changing in response to the state without me needing to go in and actually modify things because I have a. Pulling from this dot state inside of the render function. Yeah. The order of the functions doesn't really matter. Update response could be higher up if I wanted it to be. Yeah, when you define the class, it's going to go through all the methods so it knows what methods it has. And so it doesn't really matter what ordered therein. Yep. I specify it here that the inputs on change attribute is this dot update response. So when the input field changes, it's going to call the update response function and the event that did that calling is the input fields change event. And so it has access to the input field and can access the current value of the input field. Other things so far. All right, let me also instead of saying showing the current score, let me go ahead and have a div where I'm going to show. Let me actually show the current score. I'll say score colon this dot state dot score to say, all right, let's plug in the score into this section of the page. So now, okay, one plus one place to input the answer and a score that's currently zero. What I'd like to do now is when I type in a number and press return, for example, that's going to trigger like submitting my response as a potential answer. And so the input field, there is no attribute of the input field. It's like when you press return. But there is on key press, like press any key. And so we're going to need to use that. We're going to need to say, whenever a key is pressed, let's go ahead and call like a function. We'll call it this dot input key press. But again, it could be called anything we want to. And let's inside of the input key press function, we'll take the event. If I want to get what the key is that actually pressed, that's as simple as saying event dot key. And so if event dot key is equal to enter and JavaScript is a slight difference between what double equal sign is and what triple equal sign is, triple equal sign is going to do strict equality, making sure things really match, including the types of things. And so in general, safest use triple equal sign if you can. So I'm saying if the key that I pressed is enter, then I want to go ahead and do something. And so one thing I could do is, well, let me propose the question. What do I want to do now? Now that I've pressed enter and I'm running code that will run when I press enter after typing in a potential number. What should happen? Check what? Check if the answer is right. Great. So I want to check if the answer is right. And so what is the answer? What is the answer? Well, the answer is stored inside of this dot state dot response, right? That is what it is that the user has typed in. But of course, what the user has typed in is a string. And so in order to turn it into an integer in Python, we just used a function called int in JavaScript. It happens to be called parse int to say, take the string, parse it as an integer and save it inside of this variable called response. And so now what is the code for checking if I got the answer right? What does that look like? How do I know I got this addition problem right? Yeah. Yeah. Great. I've got num one and num two here stored inside of the state. So to check if I got the answer correct, I'm going to say if answer is equal to this dot state dot num one. Plus this dot state dot num two. I'm going to do something if the answer is right. Else, I need to do something if the answer is wrong. Questions about this much? I've now verified whether the answer is right or wrong based on the state. Yeah. Does the program know that the values are numeric? No, it's possible that parse int is going to get something that's not numeric. And that's why we have to try and parse it first into an integer. Num one and num two are definitely going to be integer numbers because we've said in this dot state that they are in fact integers. But the response you write is a string. All right. So if the answer is right, we want to change the state state. And how would we want to change the state? I'll go ahead and say state arrows so that we can base it off the previous state if we need to. But what about the state needs to change if I got the answer correct? Just in English, not necessarily in code. Yeah. The score. Great. So the score needs to change. The score needs to become state dot score plus one. And the numbers need to change too. I don't want to change what number one and number two are so I can show a different question. So num one is going to be a new number. And let me just go ahead and pick a random number. And so a common way that you'll see it of generating random numbers. Most languages have a way of generating a random number between zero and one. And in Python, the way to generate a random number between in JavaScript to do that, it's math dot random. That's going to generate a random number between zero and one. If I multiply that by ten, that's going to generate for me a random number between zero and ten, non inclusive. And on the upper bound at least. And so if I want to generate take a potential floating point number like two point eight, a decimal number between zero and ten and convert it into an integer. I'll either need to take the floor of that or the ceiling of that. I'll go ahead and take the ceiling of that. In order to say if it was two point eight, make it three, for example. And so what I get by doing this is I get a random number between one and ten. By taking a random number, multiplying it by ten and taking the ceiling of that, that's a map trick you'll often see where you can generate a random number between zero and one and turn it into a random number in any range that you want to. So this code is basically just saying, let num one be some random number between one and ten. And I'll go ahead and do the same thing for num two. Num two is also just going to be some random number in the range from one to ten. Is there anything else about the state that needs to change? Yeah. Yeah, I need to clear the response. And let's see what happens if I don't do that and then we'll actually go back and do it. I'll go ahead and open up addition that HTML. Here's the problem one plus one. So I'll get the correct answer. I'll type in two press return. The problem changed. My score increased. But the two inside the input field is still there. I'd ideally like to just clear it out when you get the question correct so that I can try typing in something else. So in addition to updating the score num one and two, I'm also going to say response is equal to the empty string. Clear out the response so that I can type something new in in this position. So refresh this page one plus one. I type in a score number two. I get the question correct. The score increases. I get a new question. I answer the question correctly. I get a new question and the score increases. What should happen if I get a question wrong? Answer incorrectly. Right now nothing's happening. What should happen? What about the state needs to change? Yeah? No? Yeah? The score is not changed. Maybe this would be the error. It's not a problem. It's not a problem. It's not a problem. It's not a problem. Sure. Let's at least clear out the response so that we can say, you know what, if you get the question wrong, let's clear out the response so that you can try again. So now if I have a question and I happen to get it wrong, I type in the incorrect answer. The problems don't change. The score doesn't change, but at least the input field is now cleared out so that I can actually type in something new again. Questions about what we've done here so far? Hopefully now you're starting to see the power that React is going to give you in building user interfaces. That we're able to update the score, that we're able to have the problems change. All without me having to say go into the DOM and actually change what's at these values and query selectors to try and grab things. I just change the state of the application, the parts of the component that are going to change, and the web page is going to update on its own via React in order to reflect what it is that I want the page to look like. Yeah. If you want to save the state in a simple database or a state of this constant, but an X user, is there an easy way to do that with React? So if you want to save the state somewhere, it depends on where you want to save it. So if you want to save it on the client side, so the next time you open up the page, it's still there, that you can use local storage for it. Probably take a look at an example of that tomorrow. If you want to save it on the server, then you're going to need to send the data off to the server somehow, and you can do that using an Ajax request like we were talking about a couple days ago, just to say, send this data off to the server so that you can store it somewhere. But yeah, you could do that. Other things? Yeah. If I enter something other than a number, so I type in high, for example, and press return, it's going to count that is incorrect. Why does it count that is incorrect? It's because if I take parse int and pass it in a string like high, what I get is a special JavaScript value called NAN or not a number. And NAN, what I'm really going to be doing is comparing whether that value is equal to like one plus one, for example. And that's always going to be false because not a number is not going to be equal to any number. And so the if condition in the logic here is going to handle dealing with non-numeric inputs for me because answer is just never going to be equal to that sum if answer is not a number. But yeah, good question and good corner case to consider. Yeah. So yeah, if you look at the example online, I add the score to num one and num two. That's two if you wanted to update the game a little bit to make it a little more difficult such that every time you get a question right, the numbers get bigger. If you take the score and add it to the numbers, then you'll end up getting more difficult math questions as the score gets higher. But yeah, no need to do that. If you put in a single. Oh, just like just the letter a. No, that's still not going to be a number because. Yeah, it's going to try and take the literal string and treat it like a number and the character a, even though it has an ASCII value that is a numeric value, the character itself is not what we would generally consider to be a number. Other questions. All right, so let's try and do something a little bit different. Let's try and now say when you reach a certain score, I would like to display some different message like when I get to a score of five, for example, let's say, okay, you won the game. So how many go about doing that? Well, I don't actually need to add anything else to the state. All I need to do here is to say. All right, this render function. Instead of having it render the entire game. Let me just rename this function to like render problem for rendering a particular problem that I want to answer. And let me go ahead and add another function called render win, for example, that returns a div that said or will return each one. Congratulations, you win. So now I have two different functions render problem and render win. And now in my actual render function, I can add logic to this render doesn't just need to return something. I can add any JavaScript logic I want. I can say if this dot state dot score is at least five, then go ahead and return render win. Otherwise, if the score is not at least five, let me return render problem. So I've added some logic to the render function known as conditional rendering. Depending upon the value of the state, I can render different things on the page. And so what's that going to do? By adding this simple logic, now, oh, something's wrong, render problem is not defined. Oh, this dot render win and this dot render problem, because they're both methods inside of this component. So I'm going to refresh the page. We get one plus one, answer the question correctly, answer the question correctly, correct, correct. And when I get the fifth question correct, now suddenly my score is going to be at least five and the interface changes. And that's as congratulations, you win because we've reached a different branching point in this conditional. You get the question correct. And as a result, we get different input or different output that gets displayed to the screen. As soon as you reload the page in this instance, we get reset back to the original state because we're reloading the whole page. It's running the JavaScript again. It's going to reconstruct all of my components and it's going to reset the state back to the original value of the state. And so as someone was mentioning before, you could save the state in local storage. And we'll probably see an example of that tomorrow if you wanted to retrieve it back later afterwards. Yeah. Is there a reason you would start with one of our students talking in? If you wanted to, you could start with random numbers other than one plus one. You just have to change the initial value of the state, changing them to random numbers instead of having them initially be one in one. But yeah, you could do that too. Yep. So is this calling render whenever you change the state or what is calling render? How do you know when they call renders and when the same group is ordered? So when react calls render is part of react abstraction whereby it's going to call render whenever it needs to and react is going to compute based upon the state when it needs to rerender. And in particular, it's not even going to rerender everything. It's only going to rerender the parts of the renders return value that actually need to change. And so if I'm typing something into the input field, the contents of the H1 that's displaying the problem, something plus something, that's not changing. And so react is not going to bother rerendering that part even though other parts of the application are changing. And so react is going to be smart about it, figuring out which parts of the DOM need to be reloaded and rerendered in response to the changing state of the application. Other things? Yeah? Yes, you could definitely separate stuff into different files. And in fact, tomorrow we'll probably take a look at the more canonical way of doing things like this whereby we'll actually use a little bit of node in order to do that too. But more on that later. Yeah? Oh, good question. So in the application that I demonstrated a moment ago, the original version, when the question was wrong, I changed the color of the problem. Like we changed it from just being black to being red text. And so we could implement that feature here now. In order to do that, whether or not the text is red, that's an additional piece of the state, right? That's something that the application state needs to know about. And so I'll go ahead and add to this.state a key called incorrect that is going to be equal to false. I saw a couple of red frowning faces. Questions before I go on? Alright, feel free to find me during project time or ask questions later too if you want to. Alright, so initially we're going to say incorrect is false, meaning the problem is not incorrect. And let me go ahead and say here, if you get the question wrong, let me set incorrect to true. For example, we'll change incorrect from false to true if we get it incorrect. And now what I'm going to do is take this H1, the information about that's displaying the problem. And I'm going to give it a class name. A class name is basically the same thing as what a class is in regular HTML. But in React, we have to call it class name instead of class because class is already a keyword in React or in JavaScript more generally that stands in for the class of the application. And so I'm going to give this H1 a class name. And in order to do this, I'm going to use some special JavaScript syntax called the ternary operator. The ternary operator is very common, you'll see it in React a lot. But basically the idea of the ternary operator is I ask a Boolean expression question. I add a question mark and then I have a value for if the expression is true and then a value for if the expression is false. And so this is like a shorthand way of creating an if else expression. I basically just put a Boolean expression on the first hand side, add a question mark, and then add two values. A value if the expression evaluates to true and a value for if it evaluates to false. And so I can say class name. All right, if this dot state dot incorrect, meaning if inside the state I've gotten the question wrong, let me go ahead and give the H1 a class name of incorrect. But otherwise if I didn't get it incorrect, then it doesn't need a class name. So I'll just go ahead and put two double quotes meaning empty string, no class name here. And so now only if the problem is incorrect, then H1 is going to have a class of incorrect. And so now up in this header, I can just do normal CSS code. I can add some style code that says if something has a class of incorrect, then go ahead and color it red. And so now by adding style for what should happen if you have a class of incorrect, and by adding to this H1, a class name that is only going to be incorrect, is I've actually gotten the question wrong. Now when I load this page, I type in the answer, I get it right. I type in the answer and I get it wrong. The color changes to red. Because it's gotten that new class of incorrect. There's a small bug here. Anyone catch what the bug might be based on the code that I've written? Yeah. Will it switch back? Will it? I type 15, I get the answer correct. And no, I get a new problem, but the color didn't switch back. And that's because I need to additionally say down here if I get the question right, well then I better set incorrect equal to false so that it goes back to having a color of black afterwards. So I try again, I get the question right, I get the question wrong, and I get the question right, it changes back from red to black. By changing the value of the state, the interface updates automatically. What questions do you have? All right, in that case what I thought we'd do is I'll help get you started on what's going to be the morning project and one of the canonical things to do with React when you first try to do it is to try and create like a to do list application. An application where you can just add tasks and remove tasks from them. And so we'll go ahead and give that a try. In order to do that, there are a couple of, let me jump ahead for a moment. There are a couple of useful JavaScript tips and tricks that you might want to take advantage of. So recall that when you have application state, you should never change state directly. You should never say this dot state dot whatever something equals something else in order to change the state directly. You should always be calling this dot set state. But if you wanted to manipulate the state without changing the original state, you might want to like create a copy of a list. And so this is something that's probably going to come up. So I'll show it to you now. If I have a list of things and like list one equals one, two, three, four, five, and I want to make a copy of that list so that I can manipulate that copy. You can do something like this. The dot dot dot list one is basically saying like fill in list one into this list. And so copy is also going to be a list one, two, three, four, five, but it's going to be a copy of that list. And we'll see in a moment why that might be helpful. If I wanted to make a copy of the list and add something to the end of it, well, then it's as simple as syntax like this list one is one, two, three, four, five list two is fill in all of list one here and then add the number six. And you can imagine this might be useful if, for instance, you're building a to do list application, you have a list of things to do, and you want to add on one more thing to do at the end, for example, you've got a whole list and you want to tack on something at the end of it. So that might be useful as well. You might also want to delete something from a list. And in order to remove something from a list, one easy way to do that in JavaScript is the splice method. And so if I have list one, one, two, three, four, five, and I say list one dot splice and then three comma one, what that's saying is pull out elements starting at index three. That's the first argument. And the second argument is how many things should I pull out of that list? And so here I'm saying from index three in the array, which is the number four, go ahead and remove one element. And so now we get one, two, three, five. So just a couple of little tips and tricks for interacting with JavaScript lists, since this is syntax you probably haven't seen before, but it's ultimately going to be helpful. So let's go ahead and get started with this to-do list application. I'll go ahead and create a new file. We'll call it todo.html. I'll go ahead and copy the contents of Hello just to get us started. The title will be todo. And we'll delete the Hello component, so we don't really need it. And okay, here's our application, constructor, props. What is the state of our todo list application? What are the things we need to keep track of? So if you wanted to append something to a list by setting this in, by setting the state, you should do it this way by making a copy of the original list and then adding something to the end of it. And that's again for security reasons for the race condition issue that I mentioned before, that you want to make a copy of the state instead of actually modifying the state directly. Okay, to do list application, what do I need to keep track of? And I'll show you what the finished product should look like in case that helps. We'll just create something that looks a little something like this. We've got tasks, a window bar that shows you how many tasks you have. You add a thing to do, add that as another task, pet otter, add that as another task. So we've got this growing list of tasks, and if you want to, you can add the support for deleting them, checking them off. So what is the state of the application? What things can change? The tasks, yeah, all the tasks themselves. That's going to start out just being an empty array. There's no tasks to begin with. And what else? There's one other piece of the state. What else changes here? Yeah? Whether they're complete or not, sure, you could implement it by keeping track of whether the task is complete or not. You could also implement it just by removing the task from the list if it's complete, since it's not going to come back. So certainly that's something you could add if you wanted to. The input field, great. This is something that changes when I start typing the value of the input field changes. And so I'll go ahead and give it an input that at least initially is going to be blank. What is the render function going to do? Well, let's go ahead and render in H1 that just says tasks, for example. And in unordered list, where I'm just going to list all of the tasks. And so how am I going to do that? Let me just go ahead and, for sake of example, start us off with a couple tasks, like thing one, thing two, thing three in terms of things to do. If I want to create one list item for every single thing in this.state.tasks, well then we can go back to functional programming, which we introduced a couple of days ago, and recall that if I want to insert here is going to be this.state.tasks, and then I can say dot map. Remember map is a function that takes an array and goes over every element in the array, so it takes me apply some function to it. And so I'm going to map over here, and we're going to map over and take every task, and we're going to, I'll go ahead and fix the spacing a little bit. And for every task, we're going to go ahead and return some list item. And that list item, at least for now, we'll just go ahead and say, let's print out the task there. So long story short, we have an unordered list, and we're going to take inside this unordered list, go over this.state.tasks, mapping over it, going one task at a time, and for each task, we're going to go ahead and print out a list item that's going to be equal to whatever the value of the task is. Let me go ahead and open up to do.html now so we can see what that looks like. All right, great. Now we have tasks, and we have this loop that's going over, creating one list item for each element. Yeah. You could also do a for loop in order to do the same thing, so you do a for loop sort of add to this growing string, for instance, and then insert that string into the HTML page, you could do that too. One error you'll notice here, and this is just a nuance of React that might be worth solving, is you get a warning if you do something like this, which is that each child in an array or iterator, should have a unique key prop. And basically, all this is saying is that if you're looping over something and creating a whole bunch of elements, React would like you to give all of them a unique property called key. And it does this for efficiency sake so that if you're updating only one element in the list, it doesn't need to also update all the other elements. It can just update the one question. And so we'll give this a unique key. The task name might not necessarily be unique, but an additional feature of map is that it can loop over all the tasks, but you can also give this function the optional argument i for index that will let you access like which index into the array is this right now. And so I'll go ahead and give this a key of i, meaning the first one will be task zero, then one, then two, so forth. Yes? If you start splicing the array, the indices will be the same, but React is going to be smart enough to know that because the element that that index has changed, that it's still going to be able to re-render it correctly. Okay, so if you do that, just add key equals i to it, then when you refresh it, you'll get rid of that warning. So, all right, great. We've gotten this list of tasks now. We're also going to want an input field, right, underneath this list of tasks, whereby I can have an input field that is going to have a value of this.state.input, and probably also a button, and I'll actually put all this inside of a div. And a button called add task. So I have an input field, what did I do wrong? Oh, an input field whose value is whatever the current value of the input is, and also a button that's going to add a new task for me. I refresh this page, and all right, now I have an input field, and I have a button to add tasks. But much like with the addition game example, if I start trying to type a task here, nothing shows up on the screen because I actually need to add, in the same as before, an on change handler. To say, when I change the value of the input field, call the handle change function, and okay, what is handle change going to do? Well, it's going to be a function that just sets the state. The function needs to take the event as its argument, and we're going to set the state, and the new value of the input is the event.target.value. Same as before, when I make a change to the input field, update the input value inside of my state currently. So I refresh this, and now I can actually type a new task into the task page. Clicking add task, of course, doesn't really do anything just yet. So let's make it do something. Button on click. Let's go ahead and run a function called this.addTask, for example, for when you click on a button. AddTask is going to go ahead and be a function. And we're probably going to want to update the state somehow here. Set the state to be something new. And I'll go ahead and do this.setState. It's going to take the original state as its input, and the new state is going to be... What? What should the new tasks be? Yeah? Great. It's going to be whatever the current list is, state.tasks, and then state.input, which is whatever it is that I've currently typed into the text field. So I'm updating the state, adding that task. I'll go ahead and remove these sample tasks, so that we can get started with something. Go ahead and refresh the page. So tasks, I can type task 1 here. Add the task, and all right, task 1 shows up. Granted, it stayed here in the text field, but that's something we can fix later, too. I type in a second task, click AddTask, and all right. That task is added to the list as well. Questions about what we've done here so far? All right. In that case, I'll post a distribution code in just a moment, but we'll go ahead and break for our morning project here. We'll create the two lists to app. We're going to allow the user to type in a task, add a new task to a list of tasks, and delete a task by clicking a button next to each task. I'll give you a suggestion of the sort of order in which to do things. I'll post a distribution code in a moment if you'd like to take a look at it and use that as a reference point. I'd start by just displaying on screen the current number of tasks. See if you can figure out a way to on the application, get the page to draw information from the state to display like you currently have four tasks in your task list, for example, and display that information. Once you get that working, go ahead and see if you can clear out the input field after we add a new task so that you type something in, you press add task and the input field clears out so that you can type in a new task. Thing to do after that is going to be let's take each task in the task list. In addition to just displaying the task, also display a button next to it, with maybe an X or a check mark to say completing this task, and just add that button there so that every list item has a button with it. And then finally, as a final challenge of your up for it, make it such that when you click on that button, that actually triggers changing the state so that we remove that task from the list of tasks. Therefore, allowing you to complete and add new tasks to your task application. If you'd like to, feel free to add other features as well, or feel free to take the game from earlier this morning and add features to that too. As part of the morning project, we'll go ahead and all just stay in this room for this morning and we'll go until 12.30 and then break it for lunch then and reconvene it to a clock.